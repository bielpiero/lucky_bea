[ DORIS] [2018-03-14 16:28:52]: Created thread RNRecurrentTask: Factory Sensors Task with Id 618498520668633920
[ DORIS] [2018-03-14 16:28:52]: new position is: {x: 1.500000, y: 3.420000, ϑ: 0.000000}
[ DORIS] [2018-03-14 16:28:52]: Created thread RNRecurrentTask: Kalman Localization Task with Id 620051786992905024
[ DORIS] [2018-03-14 16:28:52]: Thread RNRecurrentTask: Kalman Localization Task (14957929229120) is running with processId 0
(0, 0): 1.5000000	
(1, 0): 3.4200000	
(2, 0): 0.0000000	
[ DORIS] [2018-03-14 16:28:52]: Position {ux: 0.002483 m^2, uy: 0.002733 m^2, uth:0.000015 rads^2}
[ DORIS] [2018-03-14 16:28:52]: Process {ux: 0.001667 m^2, uth: 0.000471 rads^2}
[ DORIS] [2018-03-14 16:28:52]: Laser {ux: 0.000217 m^2, uth:0.000027 rads^2}
[ DORIS] [2018-03-14 16:28:52]: Camara {ux: 0.000567 m^2, uth:0.000115 rads^2}
(0, 0): 1.5000000	
(1, 0): 3.4200000	
(2, 0): 0.0000000	
[ DORIS] [2018-03-14 16:28:52]: Thread RNRecurrentTask: Factory Sensors Task (14957937621824) is running with processId 0
[ DORIS] [2018-03-14 16:28:54]: Going to: {x: 4.000000, y: 3.900000, ϑ: 0.000000}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2560.459717, DeltaTheta: 9.978408}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.174
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2560.459717, DeltaTheta: 9.978408}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.174
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2560.091309, DeltaTheta: 9.882008}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.172
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2560.091309, DeltaTheta: 9.706683}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.169
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2559.906006, DeltaTheta: 9.597438}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.168
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2559.611572, DeltaTheta: 9.299634}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.162
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2559.611572, DeltaTheta: 8.948984}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.156
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:54]: {Distance: 2559.561768, DeltaTheta: 8.618452}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.150
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:54]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2559.561768, DeltaTheta: 8.267802}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.560
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.144
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2559.298096, DeltaTheta: 7.857565}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.137
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.905273, DeltaTheta: 7.443189}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.130
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.905273, DeltaTheta: 7.180201}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.125
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.587646, DeltaTheta: 6.783440}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.118
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.587646, DeltaTheta: 6.345127}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.111
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.835449, DeltaTheta: 5.985973}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.104
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2559.104248, DeltaTheta: 5.504786}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.096
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2559.104248, DeltaTheta: 5.154136}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.090
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:55]: {Distance: 2558.229980, DeltaTheta: 4.730881}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.558
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.083
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:55]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2558.518311, DeltaTheta: 4.189344}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.073
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2558.518311, DeltaTheta: 3.838694}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.559
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.067
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2557.630615, DeltaTheta: 3.370250}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.558
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.059
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2557.630615, DeltaTheta: 3.019599}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.558
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.053
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2556.076172, DeltaTheta: 2.617101}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.556
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.046
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2555.314209, DeltaTheta: 2.218848}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.555
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.039
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2556.313721, DeltaTheta: 1.867399}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.556
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.033
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2556.461670, DeltaTheta: 1.374771}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.556
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.024
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2556.461670, DeltaTheta: 1.024121}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.556
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.018
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.213/PFar + 0.787/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.213] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.787] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.07133e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.213,Zero),AlgebraicProduct(0.787,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0607205
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.240/SlowLeft + 0.760/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.213,SlowLeft),AlgebraicProduct(0.787,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: -0.000000, rot-vel: 3.479030}
[ DORIS] [2018-03-14 16:28:56]: {Distance: 2554.923096, DeltaTheta: 0.666293}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.555
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.837/PFar + 0.163/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.837] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.163] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.15449e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.837,Zero),AlgebraicProduct(0.163,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0467831
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.873/SlowLeft + 0.127/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.837,SlowLeft),AlgebraicProduct(0.163,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:56]: {lin-vel: 0.000000, rot-vel: 2.680474}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2553.896973, DeltaTheta: 0.234668}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.554
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.798/PNear + 0.202/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.798] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.202] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.05517e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,Zero),AlgebraicProduct(0.202,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0315823
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.395/VSlowLeft + 0.436/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,VSlowLeft),AlgebraicProduct(0.202,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: 1.809532}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2553.896973, DeltaTheta: -0.028319}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.554
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2552.910400, DeltaTheta: -0.375596}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.553
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.535/NFar + 0.465/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.535] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.465] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.02849e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.535,Zero),AlgebraicProduct(0.465,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0270351
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.743/SlowRight + 0.771/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.535,SlowRight),AlgebraicProduct(0.465,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: -1.548998}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2551.910400, DeltaTheta: -0.551102}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.552
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.948/NFar + 0.052/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.948] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.052] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.74369e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.948,Zero),AlgebraicProduct(0.052,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0287789
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.769/SlowRight + 0.692/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.948,SlowRight),AlgebraicProduct(0.052,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: -1.648911}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2548.829102, DeltaTheta: -0.676153}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.549
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.180/NVeryFar + 0.820/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.180] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.820] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.82619e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,Zero),AlgebraicProduct(0.820,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0322001
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.821/SlowRight + 0.536/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,FastRight),AlgebraicProduct(0.820,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: -1.844929}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2547.300293, DeltaTheta: -0.705917}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.547
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.232/NVeryFar + 0.768/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.232] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.232,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.232,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.768] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.768,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.768,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.79778e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.232,Zero),AlgebraicProduct(0.768,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0333231
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.838/SlowRight + 0.485/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.232,FastRight),AlgebraicProduct(0.768,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: -1.909274}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2546.300293, DeltaTheta: -0.443154}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.546
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.694/NFar + 0.306/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.694] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.694,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.694,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.306] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.306,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.306,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.75494e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.694,Zero),AlgebraicProduct(0.306,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0279174
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.756/SlowRight + 0.731/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.694,SlowRight),AlgebraicProduct(0.306,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: 0.000000, rot-vel: -1.599552}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2545.652100, DeltaTheta: -0.382602}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.546
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.551/NFar + 0.449/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.551] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.551,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.551,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.449] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.449,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.449,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.99312e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.551,Zero),AlgebraicProduct(0.449,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0271411
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.745/SlowRight + 0.766/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.551,SlowRight),AlgebraicProduct(0.449,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: -0.000000, rot-vel: -1.555070}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2544.599854, DeltaTheta: -0.233424}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.545
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.199/NFar + 0.801/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.199] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.801] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.77024e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.199,Zero),AlgebraicProduct(0.801,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0240826
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.698/SlowRight + 0.905/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.199,SlowRight),AlgebraicProduct(0.801,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: 0.000000, rot-vel: -1.379834}
[ DORIS] [2018-03-14 16:28:57]: {Distance: 2544.599854, DeltaTheta: -0.233424}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.545
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.199/NFar + 0.801/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.199] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.801] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.77024e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.199,Zero),AlgebraicProduct(0.801,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0240826
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.698/SlowRight + 0.905/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.199,SlowRight),AlgebraicProduct(0.801,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:57]: {lin-vel: 0.000000, rot-vel: -1.379834}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2543.613770, DeltaTheta: -0.012405}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.544
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2543.613770, DeltaTheta: 0.162921}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.544
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.967/PNear + 0.033/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.967] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.967,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.967,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.033] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.033,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.033,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.77185e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.967,Zero),AlgebraicProduct(0.033,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0262355
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.328/VSlowLeft + 0.193/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.967,VSlowLeft),AlgebraicProduct(0.033,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: -0.000000, rot-vel: 1.503183}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2541.925293, DeltaTheta: 0.144087}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.542
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.066/Zero + 0.934/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.934] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.066] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.94417
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.268/Backwards + 0.000/MediumBackwards + 0.803/Zero + 0.197/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.934,Zero),AlgebraicProduct(0.066,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0217733
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.003/SlowRight + 0.000/VSlowRight + 0.010/Zero + 0.272/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.934,VSlowLeft),AlgebraicProduct(0.066,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 3.944173, rot-vel: 1.247521}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2538.432373, DeltaTheta: 0.248769}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.538
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.765/PNear + 0.235/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.765] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.235] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.86829e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,Zero),AlgebraicProduct(0.235,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0324607
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.406/VSlowLeft + 0.475/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,VSlowLeft),AlgebraicProduct(0.235,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: -0.000000, rot-vel: 1.859862}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2538.432373, DeltaTheta: 0.248769}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.538
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.765/PNear + 0.235/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.765] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.235] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.86829e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,Zero),AlgebraicProduct(0.235,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0324607
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.406/VSlowLeft + 0.475/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,VSlowLeft),AlgebraicProduct(0.235,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: -0.000000, rot-vel: 1.859862}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2536.495361, DeltaTheta: 0.289224}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.536
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.669/PNear + 0.331/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.669] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.331] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.74732e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.669,Zero),AlgebraicProduct(0.331,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0347177
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.434/VSlowLeft + 0.578/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.669,VSlowLeft),AlgebraicProduct(0.331,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: -0.000000, rot-vel: 1.989179}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2535.495361, DeltaTheta: 0.026299}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2535.064453, DeltaTheta: -0.050831}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2532.605957, DeltaTheta: 0.023302}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.533
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:58]: {Distance: 2529.443604, DeltaTheta: -0.064386}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.529
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2523.871338, DeltaTheta: -0.247868}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.524
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.233/NFar + 0.767/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.233] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.233,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.233,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.767] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.767,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.767,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.10578e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.233,Zero),AlgebraicProduct(0.767,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0244523
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.704/SlowRight + 0.889/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.233,SlowRight),AlgebraicProduct(0.767,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: -1.401016}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2515.329590, DeltaTheta: -0.328581}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.515
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.424/NFar + 0.576/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.424] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.424,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.424,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.576] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.576,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.576,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.83562e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.424,Zero),AlgebraicProduct(0.576,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.02623
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.731/SlowRight + 0.808/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.424,SlowRight),AlgebraicProduct(0.576,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: -1.502871}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2508.258545, DeltaTheta: -0.417293}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.508
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.633/NFar + 0.367/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.633] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.633,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.633,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.367] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.367,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.367,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.71401e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.633,Zero),AlgebraicProduct(0.367,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0276154
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.752/SlowRight + 0.745/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.633,SlowRight),AlgebraicProduct(0.367,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: -1.582248}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2502.844727, DeltaTheta: -0.366828}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.503
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.514/NFar + 0.486/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.514] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.486] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.17583e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.514,Zero),AlgebraicProduct(0.486,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0268975
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.741/SlowRight + 0.777/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.514,SlowRight),AlgebraicProduct(0.486,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: -1.541112}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2502.844727, DeltaTheta: -0.279166}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.503
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.307/NFar + 0.693/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.307] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.307,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.307,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.693] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.693,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.693,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.0897e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.307,Zero),AlgebraicProduct(0.693,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.025201
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.715/SlowRight + 0.854/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.307,SlowRight),AlgebraicProduct(0.693,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: -1.443912}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2505.748779, DeltaTheta: -0.043466}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.506
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2507.992188, DeltaTheta: 0.427223}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.508
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.344/PNear + 0.656/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.344] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.344,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.344,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.656] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.656,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.656,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.52756e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.344,Zero),AlgebraicProduct(0.656,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0401355
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.502/VSlowLeft + 0.824/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.344,VSlowLeft),AlgebraicProduct(0.656,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: 2.299596}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2506.992188, DeltaTheta: 0.515074}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.507
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.137/PNear + 0.863/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.137] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.137,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.137,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.863] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.863,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.863,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.28479e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.137,Zero),AlgebraicProduct(0.863,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0422901
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.529/VSlowLeft + 0.922/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.137,VSlowLeft),AlgebraicProduct(0.863,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: 2.423045}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2503.032715, DeltaTheta: 0.365187}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.503
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.490/PNear + 0.510/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.490] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.490,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.490,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.510] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.510,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.510,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.99474e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.490,Zero),AlgebraicProduct(0.510,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0380709
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.476/VSlowLeft + 0.730/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.490,VSlowLeft),AlgebraicProduct(0.510,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: -0.000000, rot-vel: 2.181303}
[ DORIS] [2018-03-14 16:28:59]: {Distance: 2501.254883, DeltaTheta: 0.029858}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.501
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:28:59]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2499.254883, DeltaTheta: -0.057816}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.499
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2498.385254, DeltaTheta: -0.081817}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.498
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.098/NNear + 0.902/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.098] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.902] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.1102
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.294/Forward + 0.706/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,Zero),AlgebraicProduct(0.902,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00197106
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.363/SlowRight + 0.090/VSlowRight + 0.910/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,VSlowRight),AlgebraicProduct(0.902,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: 54.110198, rot-vel: -0.112934}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2495.385254, DeltaTheta: -0.169631}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.495
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.049/NFar + 0.951/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.049] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.049,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.049,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.951] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.951,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.951,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.75641e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.049,Zero),AlgebraicProduct(0.951,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.022291
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.671/SlowRight + 0.987/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.049,SlowRight),AlgebraicProduct(0.951,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: -0.000000, rot-vel: -1.277181}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2492.298584, DeltaTheta: -0.280809}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.492
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.311/NFar + 0.689/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.311] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.311,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.311,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.689] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.689,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.689,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.33383e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.311,Zero),AlgebraicProduct(0.689,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252383
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.716/SlowRight + 0.853/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.311,SlowRight),AlgebraicProduct(0.689,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: -0.000000, rot-vel: -1.446047}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2485.622559, DeltaTheta: -0.334081}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.486
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.437/NFar + 0.563/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.437] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.563] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.6996e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,Zero),AlgebraicProduct(0.563,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263329
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.732/SlowRight + 0.803/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,SlowRight),AlgebraicProduct(0.563,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: -0.000000, rot-vel: -1.508762}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2481.499512, DeltaTheta: -0.159166}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.481
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.024/NFar + 0.976/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.024] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.976] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.36162e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.024,Zero),AlgebraicProduct(0.976,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0219768
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.666/SlowRight + 0.999/VSlowRight + 0.001/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.024,SlowRight),AlgebraicProduct(0.976,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: -0.000000, rot-vel: -1.259180}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2479.905029, DeltaTheta: 0.114189}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.467/Zero + 0.533/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.533] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.533,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.533,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.467] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.467,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.467,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 28.0647
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.597/MediumForward + 0.403/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.533,Zero),AlgebraicProduct(0.467,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0085558
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.204/SlowRight + 0.000/VSlowRight + 0.611/Zero + 0.107/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.533,VSlowLeft),AlgebraicProduct(0.467,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: 28.064656, rot-vel: 0.490211}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2481.415283, DeltaTheta: 0.124130}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.481
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.333/Zero + 0.667/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.667] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.333] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.0514
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.997/MediumForward + 0.003/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,Zero),AlgebraicProduct(0.333,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0119958
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.152/SlowRight + 0.000/VSlowRight + 0.455/Zero + 0.150/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,VSlowLeft),AlgebraicProduct(0.333,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: 20.051447, rot-vel: 0.687310}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2482.415283, DeltaTheta: 0.124080}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.482
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.334/Zero + 0.666/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.666] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.334] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.0918
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.995/MediumForward + 0.005/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,Zero),AlgebraicProduct(0.334,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0119766
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.152/SlowRight + 0.000/VSlowRight + 0.456/Zero + 0.150/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,VSlowLeft),AlgebraicProduct(0.334,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: 20.091773, rot-vel: 0.686208}
[ DORIS] [2018-03-14 16:29:00]: {Distance: 2479.778320, DeltaTheta: 0.283271}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.683/PNear + 0.317/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.683] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.683,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.683,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.317] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.317,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.317,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.29281e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.683,Zero),AlgebraicProduct(0.317,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0344085
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.430/VSlowLeft + 0.564/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.683,VSlowLeft),AlgebraicProduct(0.317,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:00]: {lin-vel: -0.000000, rot-vel: 1.971460}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2476.778320, DeltaTheta: 0.108183}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.477
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.548/Zero + 0.452/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.452] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.548] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 32.9025
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.355/MediumForward + 0.645/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,Zero),AlgebraicProduct(0.548,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00680109
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.230/SlowRight + 0.000/VSlowRight + 0.691/Zero + 0.085/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,VSlowLeft),AlgebraicProduct(0.548,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 32.902503, rot-vel: 0.389674}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2473.599365, DeltaTheta: -0.121216}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.474
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.627/NNear + 0.373/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.627] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.627,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.627,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.373] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.373,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.373,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.4009
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.880/MediumForward + 0.120/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.627,Zero),AlgebraicProduct(0.373,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0137953
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.542/SlowRight + 0.627/VSlowRight + 0.373/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.627,VSlowRight),AlgebraicProduct(0.373,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 22.400867, rot-vel: -0.790414}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2471.235107, DeltaTheta: -0.121740}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.471
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.634/NNear + 0.366/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.634] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.634,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.634,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.366] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.366,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.366,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.9783
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.901/MediumForward + 0.099/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.634,Zero),AlgebraicProduct(0.366,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0139546
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.545/SlowRight + 0.634/VSlowRight + 0.366/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.634,VSlowRight),AlgebraicProduct(0.366,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 21.978251, rot-vel: -0.799540}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2469.235107, DeltaTheta: -0.121839}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.469
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.636/NNear + 0.364/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.636] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.364] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.8987
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.905/MediumForward + 0.095/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.636,Zero),AlgebraicProduct(0.364,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0139846
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.545/SlowRight + 0.636/VSlowRight + 0.364/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.636,VSlowRight),AlgebraicProduct(0.364,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 21.898750, rot-vel: -0.801256}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2467.712646, DeltaTheta: -0.169626}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.468
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.049/NFar + 0.951/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.049] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.049,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.049,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.951] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.951,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.951,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.0673e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.049,Zero),AlgebraicProduct(0.951,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0222909
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.671/SlowRight + 0.987/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.049,SlowRight),AlgebraicProduct(0.951,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: -0.000000, rot-vel: -1.277172}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2465.476807, DeltaTheta: 0.093327}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.465
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.747/Zero + 0.253/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.253] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.253,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.253,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.747] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.747,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.747,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.8576
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.757/Forward + 0.243/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.253,Zero),AlgebraicProduct(0.747,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00326683
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.284/SlowRight + 0.000/VSlowRight + 0.852/Zero + 0.041/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.253,VSlowLeft),AlgebraicProduct(0.747,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 44.857583, rot-vel: 0.187176}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2463.287598, DeltaTheta: 0.284472}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.463
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.680/PNear + 0.320/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.680] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.320] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.56019e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.680,Zero),AlgebraicProduct(0.320,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0344714
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.431/VSlowLeft + 0.567/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.680,VSlowLeft),AlgebraicProduct(0.320,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: -0.000000, rot-vel: 1.975068}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2461.419434, DeltaTheta: 0.200842}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.461
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.878/PNear + 0.122/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.878] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.878,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.878,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.122] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.122,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.122,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.35031e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.878,Zero),AlgebraicProduct(0.122,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0292566
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.366/VSlowLeft + 0.330/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.878,VSlowLeft),AlgebraicProduct(0.122,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: -0.000000, rot-vel: 1.676280}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2459.183350, DeltaTheta: 0.113323}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.459
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.479/Zero + 0.521/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.521] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.521,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.521,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.479] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.479,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.479,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 28.7623
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.562/MediumForward + 0.438/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.521,Zero),AlgebraicProduct(0.479,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00828919
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.208/SlowRight + 0.000/VSlowRight + 0.623/Zero + 0.104/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.521,VSlowLeft),AlgebraicProduct(0.479,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 28.762325, rot-vel: 0.474936}
[ DORIS] [2018-03-14 16:29:01]: {Distance: 2457.880859, DeltaTheta: 0.059800}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.458
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2455.505127, DeltaTheta: 0.042127}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.456
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2452.505127, DeltaTheta: -0.045538}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.453
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2440.647217, DeltaTheta: -0.199278}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.441
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.119/NFar + 0.881/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.119] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.119,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.119,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.881] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.881,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.881,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.64167e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.119,Zero),AlgebraicProduct(0.881,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.023153
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.948/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.119,SlowRight),AlgebraicProduct(0.881,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: -1.326570}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2424.013184, DeltaTheta: -0.334188}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.424
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.437/NFar + 0.563/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.437] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.563] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.30631e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,Zero),AlgebraicProduct(0.563,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263348
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.732/SlowRight + 0.803/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,SlowRight),AlgebraicProduct(0.563,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: -1.508875}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2416.942139, DeltaTheta: -0.335165}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.417
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.439/NFar + 0.561/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.439] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.439,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.439,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.561] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.561,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.561,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.68078e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.439,Zero),AlgebraicProduct(0.561,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263529
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.733/SlowRight + 0.802/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.439,SlowRight),AlgebraicProduct(0.561,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: -1.509908}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2413.671387, DeltaTheta: -0.172524}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.414
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.056/NFar + 0.944/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.056] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.944] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.30595e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.056,Zero),AlgebraicProduct(0.944,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0223771
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.672/SlowRight + 0.983/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.056,SlowRight),AlgebraicProduct(0.944,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: -1.282111}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2413.671387, DeltaTheta: 0.002801}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.414
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2416.231934, DeltaTheta: 0.246225}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.416
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.771/PNear + 0.229/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.771] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.771,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.771,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.229] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.229,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.229,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.91249e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.771,Zero),AlgebraicProduct(0.229,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0323059
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.404/VSlowLeft + 0.468/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.771,VSlowLeft),AlgebraicProduct(0.229,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: 1.850993}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2412.601807, DeltaTheta: 0.264024}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.413
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.729/PNear + 0.271/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.729] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.729,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.729,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.271] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.271,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.271,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.34432e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.729,Zero),AlgebraicProduct(0.271,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0333558
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.417/VSlowLeft + 0.516/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.729,VSlowLeft),AlgebraicProduct(0.271,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: -0.000000, rot-vel: 1.911144}
[ DORIS] [2018-03-14 16:29:02]: {Distance: 2402.685791, DeltaTheta: 0.000837}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.403
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2394.421875, DeltaTheta: -0.134743}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.394
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.809/NNear + 0.191/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.809] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.809,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.809,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.191] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.191,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.191,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.4892
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.142/Backwards + 0.000/MediumBackwards + 0.426/Zero + 0.574/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.809,Zero),AlgebraicProduct(0.191,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0178025
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.603/SlowRight + 0.809/VSlowRight + 0.191/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.809,VSlowRight),AlgebraicProduct(0.191,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: 11.489205, rot-vel: -1.020009}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2385.812256, DeltaTheta: -0.287163}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.386
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.326/NFar + 0.674/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.326] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.674] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.22583e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.326,Zero),AlgebraicProduct(0.674,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0253804
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.718/SlowRight + 0.846/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.326,SlowRight),AlgebraicProduct(0.674,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: -0.000000, rot-vel: -1.454190}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2379.260742, DeltaTheta: -0.283011}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.379
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.316/NFar + 0.684/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.316] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.316,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.316,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.684] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.684,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.684,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.37758e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.316,Zero),AlgebraicProduct(0.684,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252879
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.716/SlowRight + 0.851/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.316,SlowRight),AlgebraicProduct(0.684,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: -0.000000, rot-vel: -1.448889}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2373.280273, DeltaTheta: -0.218150}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.373
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.163/NFar + 0.837/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.163] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.837] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.74403e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.163,Zero),AlgebraicProduct(0.837,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0236761
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.692/SlowRight + 0.924/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.163,SlowRight),AlgebraicProduct(0.837,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: -0.000000, rot-vel: -1.356538}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2367.314941, DeltaTheta: -0.341568}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.367
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.454/NFar + 0.546/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.454] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.454,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.454,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.546] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.546,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.546,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.97067e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.454,Zero),AlgebraicProduct(0.546,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0264691
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.734/SlowRight + 0.797/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.454,SlowRight),AlgebraicProduct(0.546,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: 0.000000, rot-vel: -1.516568}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2368.910889, DeltaTheta: -0.288397}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.369
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.329/NFar + 0.671/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.329] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.329,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.329,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.671] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.671,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.671,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.34932e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.329,Zero),AlgebraicProduct(0.671,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0254076
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.718/SlowRight + 0.845/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.329,SlowRight),AlgebraicProduct(0.671,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: -0.000000, rot-vel: -1.455750}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2369.730957, DeltaTheta: -0.236406}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.370
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.206/NFar + 0.794/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.206] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.794] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.1592e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,Zero),AlgebraicProduct(0.794,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0241602
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.699/SlowRight + 0.902/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,SlowRight),AlgebraicProduct(0.794,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: -0.000000, rot-vel: -1.384276}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2365.709229, DeltaTheta: -0.150650}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.366
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.004/NFar + 0.996/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.09678e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,Zero),AlgebraicProduct(0.996,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.021718
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.987/VSlowRight + 0.013/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,SlowRight),AlgebraicProduct(0.996,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: 0.000000, rot-vel: -1.244352}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2362.071777, DeltaTheta: -0.140857}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.362
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.891/NNear + 0.109/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.891] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.891,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.891,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.109] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.109,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.109,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.55307
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.224/Backwards + 0.000/MediumBackwards + 0.672/Zero + 0.328/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.891,Zero),AlgebraicProduct(0.109,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0195169
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.629/SlowRight + 0.887/VSlowRight + 0.113/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.891,VSlowRight),AlgebraicProduct(0.109,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: 6.553074, rot-vel: -1.118237}
[ DORIS] [2018-03-14 16:29:03]: {Distance: 2362.071777, DeltaTheta: -0.053195}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.362
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2361.314941, DeltaTheta: 0.017172}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.361
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2358.365723, DeltaTheta: 0.074872}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.358
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.995/Zero + 0.005/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.005] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.995] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 59.6892
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.016/Forward + 0.984/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,Zero),AlgebraicProduct(0.995,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.64947e-05
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.332/SlowRight + 0.000/VSlowRight + 0.997/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,VSlowLeft),AlgebraicProduct(0.995,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: 59.689173, rot-vel: 0.003237}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2351.526367, DeltaTheta: 0.186269}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.352
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.912/PNear + 0.088/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.912] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.088] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.2165e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,Zero),AlgebraicProduct(0.088,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0281509
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.352/VSlowLeft + 0.280/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,VSlowLeft),AlgebraicProduct(0.088,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 1.612928}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2344.947021, DeltaTheta: 0.305656}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.345
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.630/PNear + 0.370/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.630] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.630,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.630,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.370] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.370,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.370,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.05459e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.630,Zero),AlgebraicProduct(0.370,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0355334
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.444/VSlowLeft + 0.615/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.630,VSlowLeft),AlgebraicProduct(0.370,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 2.035913}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2338.704102, DeltaTheta: 0.335761}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.339
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.559/PNear + 0.441/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.559] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.559,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.559,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.441] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.441,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.441,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.45768e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.559,Zero),AlgebraicProduct(0.441,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0368933
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.461/VSlowLeft + 0.677/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.559,VSlowLeft),AlgebraicProduct(0.441,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 2.113832}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2337.172363, DeltaTheta: 0.236769}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.337
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.793/PNear + 0.207/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.793] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.793,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.793,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.207] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.207,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.207,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.33207e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.793,Zero),AlgebraicProduct(0.207,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0317164
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.396/VSlowLeft + 0.442/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.793,VSlowLeft),AlgebraicProduct(0.207,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 1.817216}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2339.102295, DeltaTheta: 0.186794}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.339
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.911/PNear + 0.089/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.911] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.911,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.911,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.089] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.089,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.089,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.81848e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.911,Zero),AlgebraicProduct(0.089,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0281919
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.352/VSlowLeft + 0.281/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.911,VSlowLeft),AlgebraicProduct(0.089,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 1.615275}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2343.172852, DeltaTheta: 0.153975}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.343
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.988/PNear + 0.012/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.988] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.012] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.18923e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.988,Zero),AlgebraicProduct(0.012,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0254515
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.318/VSlowLeft + 0.157/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.988,VSlowLeft),AlgebraicProduct(0.012,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: 1.458262}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2343.157471, DeltaTheta: -0.031763}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.343
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:04]: {Distance: 2339.851074, DeltaTheta: -0.349870}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.340
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.474/NFar + 0.526/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.474] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.474,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.474,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.526] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.526,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.526,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.74975e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.474,Zero),AlgebraicProduct(0.526,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0266152
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.737/SlowRight + 0.790/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.474,SlowRight),AlgebraicProduct(0.526,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:04]: {lin-vel: -0.000000, rot-vel: -1.524937}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2337.176025, DeltaTheta: -0.413624}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.337
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.624/NFar + 0.376/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.624] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.376] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.38344e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,Zero),AlgebraicProduct(0.376,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0275691
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.751/SlowRight + 0.747/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,SlowRight),AlgebraicProduct(0.376,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: -1.579594}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2334.717041, DeltaTheta: -0.472486}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.335
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.763/NFar + 0.237/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.763] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.763,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.763,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.237] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.237,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.237,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.21092e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.763,Zero),AlgebraicProduct(0.237,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0282112
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.761/SlowRight + 0.718/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.763,SlowRight),AlgebraicProduct(0.237,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: -1.616380}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2330.761963, DeltaTheta: -0.333629}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.331
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.436/NFar + 0.564/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.436] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.436,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.436,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.564] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.564,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.564,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.24831e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.436,Zero),AlgebraicProduct(0.564,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263245
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.732/SlowRight + 0.803/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.436,SlowRight),AlgebraicProduct(0.564,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: -1.508283}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2328.546387, DeltaTheta: -0.305455}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.329
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.369/NFar + 0.631/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.369] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.631] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.30154e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.369,Zero),AlgebraicProduct(0.631,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0257721
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.724/SlowRight + 0.829/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.369,SlowRight),AlgebraicProduct(0.631,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: -1.476632}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2327.784668, DeltaTheta: -0.211746}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.328
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.148/NFar + 0.852/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.148] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.852] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.45483e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,Zero),AlgebraicProduct(0.852,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.023501
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.689/SlowRight + 0.932/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,SlowRight),AlgebraicProduct(0.852,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: 0.000000, rot-vel: -1.346509}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2329.198730, DeltaTheta: -0.211617}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.329
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.148/NFar + 0.852/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.148] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.852] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.07291e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,Zero),AlgebraicProduct(0.852,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0234975
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.689/SlowRight + 0.932/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,SlowRight),AlgebraicProduct(0.852,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: -1.346306}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2329.935791, DeltaTheta: -0.131806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.330
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.770/NNear + 0.230/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.770] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.770,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.770,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.230] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.230,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.230,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 13.8596
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.102/Backwards + 0.000/MediumBackwards + 0.307/Zero + 0.693/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.770,Zero),AlgebraicProduct(0.230,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0169544
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.590/SlowRight + 0.771/VSlowRight + 0.229/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.770,VSlowRight),AlgebraicProduct(0.230,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: 13.859570, rot-vel: -0.971416}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2328.935791, DeltaTheta: -0.044181}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.329
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2331.496582, DeltaTheta: 0.041860}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.331
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:05]: {Distance: 2332.082031, DeltaTheta: 0.233036}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.332
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.802/PNear + 0.198/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.802] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.802,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.802,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.198] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.198,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.198,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.59181e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.802,Zero),AlgebraicProduct(0.198,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0314773
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.393/VSlowLeft + 0.431/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.802,VSlowLeft),AlgebraicProduct(0.198,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:05]: {lin-vel: -0.000000, rot-vel: 1.803518}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2328.829102, DeltaTheta: 0.429989}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.329
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.337/PNear + 0.663/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.337] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.337,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.337,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.663] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.663,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.663,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.50728e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.337,Zero),AlgebraicProduct(0.663,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0402159
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.503/VSlowLeft + 0.828/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.337,VSlowLeft),AlgebraicProduct(0.663,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: -0.000000, rot-vel: 2.304203}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2323.383545, DeltaTheta: 0.424916}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.323
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.349/PNear + 0.651/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.349] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.349,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.349,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.651] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.651,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.651,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.38278e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.349,Zero),AlgebraicProduct(0.651,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0400677
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.501/VSlowLeft + 0.821/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.349,VSlowLeft),AlgebraicProduct(0.651,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: -0.000000, rot-vel: 2.295713}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2321.654541, DeltaTheta: 0.287776}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.322
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.673/PNear + 0.327/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.673] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.673,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.673,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.327] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.327,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.327,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.07699e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.673,Zero),AlgebraicProduct(0.327,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0346432
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.433/VSlowLeft + 0.575/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.673,VSlowLeft),AlgebraicProduct(0.327,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: -0.000000, rot-vel: 1.984907}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2323.711182, DeltaTheta: 0.011947}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.324
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2326.050537, DeltaTheta: 0.054843}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.326
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2327.464600, DeltaTheta: 0.054810}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.327
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2324.812988, DeltaTheta: -0.088830}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.325
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.193/NNear + 0.807/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.193] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.807] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 48.4743
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.576/Forward + 0.424/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,Zero),AlgebraicProduct(0.807,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00395934
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.393/SlowRight + 0.180/VSlowRight + 0.820/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,VSlowRight),AlgebraicProduct(0.807,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 48.474305, rot-vel: -0.226854}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2318.339111, DeltaTheta: -0.109110}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.318
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.465/NNear + 0.535/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.465] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.535] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 32.1558
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.392/MediumForward + 0.608/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,Zero),AlgebraicProduct(0.535,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0100764
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.486/SlowRight + 0.458/VSlowRight + 0.542/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,VSlowRight),AlgebraicProduct(0.535,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 32.155831, rot-vel: -0.577335}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2309.283691, DeltaTheta: -0.021703}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.309
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:06]: {Distance: 2306.074219, DeltaTheta: -0.158317}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.306
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.022/NFar + 0.978/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.022] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.978] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.29814e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.022,Zero),AlgebraicProduct(0.978,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0219512
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.666/SlowRight + 0.998/VSlowRight + 0.002/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.022,SlowRight),AlgebraicProduct(0.978,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:06]: {lin-vel: -0.000000, rot-vel: -1.257709}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2305.918945, DeltaTheta: -0.016854}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.306
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2300.770752, DeltaTheta: -0.065542}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.301
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2297.830078, DeltaTheta: -0.081049}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.298
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.088/NNear + 0.912/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.088] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.912] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.7276
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.264/Forward + 0.736/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.088,Zero),AlgebraicProduct(0.912,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00175898
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.360/SlowRight + 0.080/VSlowRight + 0.920/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.088,VSlowRight),AlgebraicProduct(0.912,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 54.727581, rot-vel: -0.100782}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2292.330811, DeltaTheta: -0.132446}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.292
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.778/NNear + 0.222/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.778] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.222] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 13.3432
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.111/Backwards + 0.000/MediumBackwards + 0.333/Zero + 0.667/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.778,Zero),AlgebraicProduct(0.222,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0171404
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.593/SlowRight + 0.779/VSlowRight + 0.221/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.778,VSlowRight),AlgebraicProduct(0.222,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 13.343191, rot-vel: -0.982073}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2285.219727, DeltaTheta: -0.107749}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.285
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.447/NNear + 0.553/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.447] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.447,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.447,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.553] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.553,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.553,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.2519
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.337/MediumForward + 0.663/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.447,Zero),AlgebraicProduct(0.553,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0096569
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.480/SlowRight + 0.439/VSlowRight + 0.561/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.447,VSlowRight),AlgebraicProduct(0.553,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 33.251887, rot-vel: -0.553300}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2281.326660, DeltaTheta: -0.088036}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.281
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.182/NNear + 0.818/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.182] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.182,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.182,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.818] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.818,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.818,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 49.1121
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.544/Forward + 0.456/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.182,Zero),AlgebraicProduct(0.818,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00372994
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.390/SlowRight + 0.170/VSlowRight + 0.830/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.182,VSlowRight),AlgebraicProduct(0.818,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 49.112131, rot-vel: -0.213710}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2279.087402, DeltaTheta: 0.073194}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.279
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2277.010986, DeltaTheta: 0.193177}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.277
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.896/PNear + 0.104/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.896] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.896,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.896,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.104] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.104,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.104,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.88613e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.896,Zero),AlgebraicProduct(0.104,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0286832
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.359/VSlowLeft + 0.304/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.896,VSlowLeft),AlgebraicProduct(0.104,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 0.000000, rot-vel: 1.643429}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2272.887939, DeltaTheta: 0.193527}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.273
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.895/PNear + 0.105/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.895] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.895,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.895,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.105] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.105,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.105,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.93288e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.895,Zero),AlgebraicProduct(0.105,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0287098
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.359/VSlowLeft + 0.305/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.895,VSlowLeft),AlgebraicProduct(0.105,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: -0.000000, rot-vel: 1.644953}
[ DORIS] [2018-03-14 16:29:07]: {Distance: 2269.208984, DeltaTheta: 0.130954}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.269
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.242/Zero + 0.758/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.758] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.758,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.758,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.242] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.242,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.242,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 14.5473
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.091/Backwards + 0.000/MediumBackwards + 0.273/Zero + 0.727/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.758,Zero),AlgebraicProduct(0.242,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.014834
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.109/SlowRight + 0.000/VSlowRight + 0.326/Zero + 0.185/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.758,VSlowLeft),AlgebraicProduct(0.242,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:07]: {lin-vel: 14.547301, rot-vel: 0.849924}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2270.791016, DeltaTheta: 0.059149}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.271
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2272.044678, DeltaTheta: -0.052284}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.272
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2267.677246, DeltaTheta: -0.199967}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.268
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.120/NFar + 0.880/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.120] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.880] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.37354e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,Zero),AlgebraicProduct(0.880,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0231725
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.947/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,SlowRight),AlgebraicProduct(0.880,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 0.000000, rot-vel: -1.327685}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2259.237549, DeltaTheta: -0.166431}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.259
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.041/NFar + 0.959/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.041] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.041,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.041,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.959] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.959,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.959,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.72769e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.041,Zero),AlgebraicProduct(0.959,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0221954
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.670/SlowRight + 0.991/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.041,SlowRight),AlgebraicProduct(0.959,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: -0.000000, rot-vel: -1.271704}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2253.661377, DeltaTheta: -0.174970}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.254
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.061/NFar + 0.939/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.061] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.939] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.63871e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,Zero),AlgebraicProduct(0.939,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0224495
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.673/SlowRight + 0.980/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,SlowRight),AlgebraicProduct(0.939,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: -0.000000, rot-vel: -1.286261}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2253.717041, DeltaTheta: -0.287125}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.254
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.326/NFar + 0.674/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.326] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.674] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.95029e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.326,Zero),AlgebraicProduct(0.674,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0253795
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.718/SlowRight + 0.846/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.326,SlowRight),AlgebraicProduct(0.674,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: -0.000000, rot-vel: -1.454141}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2250.717041, DeltaTheta: -0.024344}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.251
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2251.917969, DeltaTheta: 0.044765}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.252
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2248.592529, DeltaTheta: -0.069121}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.249
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:08]: {Distance: 2242.304932, DeltaTheta: -0.282175}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.242
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.314/NFar + 0.686/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.314] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.314,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.314,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.686] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.686,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.686,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.6271e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.314,Zero),AlgebraicProduct(0.686,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252691
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.716/SlowRight + 0.851/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.314,SlowRight),AlgebraicProduct(0.686,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:08]: {lin-vel: -0.000000, rot-vel: -1.447813}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2236.908936, DeltaTheta: -0.026632}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.237
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2231.498535, DeltaTheta: 0.064686}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.231
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2226.433350, DeltaTheta: 0.272168}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.226
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.709/PNear + 0.291/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.709] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.709,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.709,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.291] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.291,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.291,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.71472e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.709,Zero),AlgebraicProduct(0.291,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0338113
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.423/VSlowLeft + 0.537/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.709,VSlowLeft),AlgebraicProduct(0.291,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: -0.000000, rot-vel: 1.937245}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2224.109131, DeltaTheta: 0.270326}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.224
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.714/PNear + 0.286/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.714] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.714,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.714,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.286] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.286,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.286,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.3853e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.714,Zero),AlgebraicProduct(0.286,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0337096
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.421/VSlowLeft + 0.532/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.714,VSlowLeft),AlgebraicProduct(0.286,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 0.000000, rot-vel: 1.931418}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2222.859131, DeltaTheta: 0.326009}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.223
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.582/PNear + 0.418/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.582] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.582,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.582,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.418] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.418,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.418,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.89435e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.582,Zero),AlgebraicProduct(0.418,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0364709
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.456/VSlowLeft + 0.658/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.582,VSlowLeft),AlgebraicProduct(0.418,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 0.000000, rot-vel: 2.089627}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2221.006592, DeltaTheta: 0.260723}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.221
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.736/PNear + 0.264/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.736] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.736,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.736,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.264] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.264,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.264,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.02068e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.736,Zero),AlgebraicProduct(0.264,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0331668
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.415/VSlowLeft + 0.508/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.736,VSlowLeft),AlgebraicProduct(0.264,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: -0.000000, rot-vel: 1.900317}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2217.414551, DeltaTheta: -0.042181}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.217
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2218.928467, DeltaTheta: -0.179949}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.219
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.073/NFar + 0.927/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.073] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.073,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.073,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.927] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.927,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.927,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.06559e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.073,Zero),AlgebraicProduct(0.927,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0225961
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.676/SlowRight + 0.973/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.073,SlowRight),AlgebraicProduct(0.927,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: -0.000000, rot-vel: -1.294659}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2218.131104, DeltaTheta: -0.103952}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.218
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.396/NNear + 0.604/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.396] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.604] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 36.3084
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.185/MediumForward + 0.815/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,Zero),AlgebraicProduct(0.604,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0084898
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.462/SlowRight + 0.386/VSlowRight + 0.614/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,VSlowRight),AlgebraicProduct(0.604,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: 36.308414, rot-vel: -0.486430}
[ DORIS] [2018-03-14 16:29:09]: {Distance: 2211.899658, DeltaTheta: -0.281342}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.212
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.312/NFar + 0.688/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.312] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.312,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.312,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.688] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.688,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.688,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.14066e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.312,Zero),AlgebraicProduct(0.688,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252503
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.716/SlowRight + 0.852/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.312,SlowRight),AlgebraicProduct(0.688,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:09]: {lin-vel: -0.000000, rot-vel: -1.446737}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2206.971924, DeltaTheta: -0.383444}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.207
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.553/NFar + 0.447/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.553] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.553,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.553,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.447] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.447,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.447,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.22639e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.553,Zero),AlgebraicProduct(0.447,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0271536
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.745/SlowRight + 0.766/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.553,SlowRight),AlgebraicProduct(0.447,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: -1.555786}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2207.616943, DeltaTheta: -0.232528}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.208
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.197/NFar + 0.803/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.197] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.803] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.79272e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.197,Zero),AlgebraicProduct(0.803,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0240592
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.698/SlowRight + 0.906/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.197,SlowRight),AlgebraicProduct(0.803,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: -1.378492}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2212.272705, DeltaTheta: -0.147960}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.212
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.986/NNear + 0.014/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.986] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.986,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.986,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.014] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.014,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.014,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 0.815239
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.320/Backwards + 0.000/MediumBackwards + 0.959/Zero + 0.041/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.986,Zero),AlgebraicProduct(0.014,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0214078
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.658/SlowRight + 0.973/VSlowRight + 0.027/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.986,VSlowRight),AlgebraicProduct(0.014,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: 0.815239, rot-vel: -1.226579}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2212.465332, DeltaTheta: -0.150697}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.212
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.004/NFar + 0.996/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.18882e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,Zero),AlgebraicProduct(0.996,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0217195
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.987/VSlowRight + 0.013/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,SlowRight),AlgebraicProduct(0.996,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: -1.244434}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2209.482666, DeltaTheta: -0.123777}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.662/NNear + 0.338/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.662] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.662,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.662,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.338] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.338,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.338,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.3362
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.983/MediumForward + 0.017/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.662,Zero),AlgebraicProduct(0.338,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0145711
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.554/SlowRight + 0.662/VSlowRight + 0.338/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.662,VSlowRight),AlgebraicProduct(0.338,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: 20.336208, rot-vel: -0.834862}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2208.641113, DeltaTheta: -0.150835}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.004/NFar + 0.996/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.18269e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,Zero),AlgebraicProduct(0.996,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0217237
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.987/VSlowRight + 0.013/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,SlowRight),AlgebraicProduct(0.996,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: -1.244676}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2207.119385, DeltaTheta: -0.012423}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.207
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2209.761475, DeltaTheta: 0.156731}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.982/PNear + 0.018/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.982] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.982,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.982,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.018] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.018,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.018,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.11083e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.982,Zero),AlgebraicProduct(0.018,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0256961
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.321/VSlowLeft + 0.168/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.982,VSlowLeft),AlgebraicProduct(0.018,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: 0.000000, rot-vel: 1.472278}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2211.395508, DeltaTheta: 0.214012}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.211
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.847/PNear + 0.153/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.847] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.153] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.84642e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.847,Zero),AlgebraicProduct(0.153,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0302006
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.378/VSlowLeft + 0.373/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.847,VSlowLeft),AlgebraicProduct(0.153,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: 1.730365}
[ DORIS] [2018-03-14 16:29:10]: {Distance: 2208.474854, DeltaTheta: 0.223365}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.208
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.825/PNear + 0.175/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.825] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.175] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.2493e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.825,Zero),AlgebraicProduct(0.175,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0308407
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.386/VSlowLeft + 0.402/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.825,VSlowLeft),AlgebraicProduct(0.175,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:10]: {lin-vel: -0.000000, rot-vel: 1.767042}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2208.362549, DeltaTheta: 0.206213}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.208
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.865/PNear + 0.135/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.865] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.865,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.865,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.135] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.135,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.135,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.12789e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.865,Zero),AlgebraicProduct(0.135,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0296477
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.371/VSlowLeft + 0.348/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.865,VSlowLeft),AlgebraicProduct(0.135,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: 1.698689}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2207.667236, DeltaTheta: 0.151760}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.208
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.993/PNear + 0.007/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.993] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.007] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.00751e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.993,Zero),AlgebraicProduct(0.007,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0252529
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.316/VSlowLeft + 0.148/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.993,VSlowLeft),AlgebraicProduct(0.007,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: 1.446884}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2208.726074, DeltaTheta: -0.087000}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.168/NNear + 0.832/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.168] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.832] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 49.9449
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.503/Forward + 0.497/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.168,Zero),AlgebraicProduct(0.832,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00343202
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.385/SlowRight + 0.156/VSlowRight + 0.844/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.168,VSlowRight),AlgebraicProduct(0.832,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: 49.944880, rot-vel: -0.196640}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2208.648193, DeltaTheta: -0.027633}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2206.243164, DeltaTheta: -0.057329}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.206
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2202.822998, DeltaTheta: -0.223161}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.203
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.175/NFar + 0.825/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.175] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.825] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.82762e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.175,Zero),AlgebraicProduct(0.825,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0238111
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.694/SlowRight + 0.918/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.175,SlowRight),AlgebraicProduct(0.825,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: -1.364278}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2199.483887, DeltaTheta: -0.293665}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.199
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.341/NFar + 0.659/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.341] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.659] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.87533e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,Zero),AlgebraicProduct(0.659,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0255226
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.720/SlowRight + 0.840/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,SlowRight),AlgebraicProduct(0.659,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: -1.462337}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2196.707031, DeltaTheta: -0.286417}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.197
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.324/NFar + 0.676/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.324] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.676] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.3423e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,Zero),AlgebraicProduct(0.676,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0253639
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.718/SlowRight + 0.847/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,SlowRight),AlgebraicProduct(0.676,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: -1.453243}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2194.662109, DeltaTheta: -0.205604}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.195
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.134/NFar + 0.866/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.134] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.134,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.134,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.866] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.866,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.866,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.87904e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.134,Zero),AlgebraicProduct(0.866,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0233308
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.687/SlowRight + 0.940/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.134,SlowRight),AlgebraicProduct(0.866,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: -0.000000, rot-vel: -1.336754}
[ DORIS] [2018-03-14 16:29:11]: {Distance: 2193.767822, DeltaTheta: 0.042255}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.194
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:11]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2190.151367, DeltaTheta: -0.174729}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.190
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.061/NFar + 0.939/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.061] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.939] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.79228e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,Zero),AlgebraicProduct(0.939,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0224424
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.673/SlowRight + 0.980/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,SlowRight),AlgebraicProduct(0.939,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: -0.000000, rot-vel: -1.285852}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2186.633789, DeltaTheta: -0.252376}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.187
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.244/NFar + 0.756/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.244] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.244,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.244,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.756] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.68473e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.244,Zero),AlgebraicProduct(0.756,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0245647
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.706/SlowRight + 0.883/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.244,SlowRight),AlgebraicProduct(0.756,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: -0.000000, rot-vel: -1.407452}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2177.558105, DeltaTheta: -0.299542}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.178
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.355/NFar + 0.645/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.355] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.355,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.355,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.645] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.645,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.645,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.2938e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.355,Zero),AlgebraicProduct(0.645,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0256483
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.722/SlowRight + 0.834/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.355,SlowRight),AlgebraicProduct(0.645,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: -0.000000, rot-vel: -1.469540}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2170.071289, DeltaTheta: -0.228404}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.170
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.187/NFar + 0.813/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.187] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.813] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.98359e-18
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.187,Zero),AlgebraicProduct(0.813,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0239507
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.696/SlowRight + 0.911/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.187,SlowRight),AlgebraicProduct(0.813,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: 0.000000, rot-vel: -1.372276}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2169.510742, DeltaTheta: -0.020557}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.170
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2175.471191, DeltaTheta: 0.028006}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.175
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2178.897949, DeltaTheta: 0.093767}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.741/Zero + 0.259/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.259] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.259,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.259,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.741] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.741,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.741,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.5043
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.775/Forward + 0.225/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.259,Zero),AlgebraicProduct(0.741,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00335741
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.282/SlowRight + 0.000/VSlowRight + 0.847/Zero + 0.042/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.259,VSlowLeft),AlgebraicProduct(0.741,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: 44.504322, rot-vel: 0.192365}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2178.847656, DeltaTheta: 0.237397}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.791/PNear + 0.209/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.791] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.209] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.91044e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.791,Zero),AlgebraicProduct(0.209,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0317562
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.397/VSlowLeft + 0.443/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.791,VSlowLeft),AlgebraicProduct(0.209,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: -0.000000, rot-vel: 1.819498}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2176.688477, DeltaTheta: 0.279897}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.177
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.691/PNear + 0.309/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.691] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.309] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.57558e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.691,Zero),AlgebraicProduct(0.309,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0342299
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.428/VSlowLeft + 0.556/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.691,VSlowLeft),AlgebraicProduct(0.309,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: 0.000000, rot-vel: 1.961226}
[ DORIS] [2018-03-14 16:29:12]: {Distance: 2173.911377, DeltaTheta: 0.421778}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.357/PNear + 0.643/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.357] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.643] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.643,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.643,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.82339e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.357,Zero),AlgebraicProduct(0.643,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0399745
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.500/VSlowLeft + 0.817/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.357,VSlowLeft),AlgebraicProduct(0.643,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:12]: {lin-vel: -0.000000, rot-vel: 2.290372}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2173.102783, DeltaTheta: 0.284400}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.173
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.681/PNear + 0.319/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.681] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.681,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.681,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.319] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.319,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.319,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.88109e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.681,Zero),AlgebraicProduct(0.319,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0344677
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.431/VSlowLeft + 0.567/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.681,VSlowLeft),AlgebraicProduct(0.319,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: -0.000000, rot-vel: 1.974853}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2175.305908, DeltaTheta: 0.022602}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.175
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2176.305908, DeltaTheta: -0.065051}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.176
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2175.297607, DeltaTheta: -0.087181}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.175
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.170/NNear + 0.830/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.170] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.830] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 49.8
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.510/Forward + 0.490/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,Zero),AlgebraicProduct(0.830,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00348373
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.386/SlowRight + 0.158/VSlowRight + 0.842/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,VSlowRight),AlgebraicProduct(0.830,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 49.799976, rot-vel: -0.199603}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2170.498779, DeltaTheta: -0.214414}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.170
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.154/NFar + 0.846/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.154] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.154,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.154,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.846] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.846,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.846,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.33786e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.154,Zero),AlgebraicProduct(0.846,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0235743
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.691/SlowRight + 0.928/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.154,SlowRight),AlgebraicProduct(0.846,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: -0.000000, rot-vel: -1.350705}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2170.059814, DeltaTheta: -0.168786}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.170
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.047/NFar + 0.953/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.047] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.953] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.46786e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.047,Zero),AlgebraicProduct(0.953,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0222658
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.671/SlowRight + 0.988/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.047,SlowRight),AlgebraicProduct(0.953,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: -0.000000, rot-vel: -1.275738}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2169.036621, DeltaTheta: -0.152649}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.169
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.009/NFar + 0.991/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.009] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.009,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.009,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.991] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.991,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.991,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.74305e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.009,Zero),AlgebraicProduct(0.991,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.021779
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.663/SlowRight + 0.990/VSlowRight + 0.010/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.009,SlowRight),AlgebraicProduct(0.991,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: -0.000000, rot-vel: -1.247846}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2161.714600, DeltaTheta: -0.127279}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.162
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.709/NNear + 0.291/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.709] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.709,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.709,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.291] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.291,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.291,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 17.5119
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.041/Backwards + 0.000/MediumBackwards + 0.124/Zero + 0.876/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.709,Zero),AlgebraicProduct(0.291,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0156209
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.570/SlowRight + 0.710/VSlowRight + 0.290/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.709,VSlowRight),AlgebraicProduct(0.291,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 17.511923, rot-vel: -0.895012}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2159.248779, DeltaTheta: -0.130831}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.159
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.756/NNear + 0.244/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.756] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.244] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.244,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.244,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 14.6464
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.089/Backwards + 0.000/MediumBackwards + 0.268/Zero + 0.732/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.756,Zero),AlgebraicProduct(0.244,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0166697
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.586/SlowRight + 0.758/VSlowRight + 0.242/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.756,VSlowRight),AlgebraicProduct(0.244,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 14.646432, rot-vel: -0.955104}
[ DORIS] [2018-03-14 16:29:13]: {Distance: 2164.160889, DeltaTheta: -0.065018}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.164
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:13]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2171.574707, DeltaTheta: 0.150105}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.172
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.997/PNear + 0.003/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.997] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.997,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.997,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.003] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.003,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.003,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.4591e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.997,Zero),AlgebraicProduct(0.003,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0251033
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.314/VSlowLeft + 0.141/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.997,VSlowLeft),AlgebraicProduct(0.003,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: -0.000000, rot-vel: 1.438311}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2167.252441, DeltaTheta: 0.121814}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.167
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.365/Zero + 0.635/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.635] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.635,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.635,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.365] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.365,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.365,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.9189
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.904/MediumForward + 0.096/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.635,Zero),AlgebraicProduct(0.365,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0111271
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.165/SlowRight + 0.000/VSlowRight + 0.494/Zero + 0.139/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.635,VSlowLeft),AlgebraicProduct(0.365,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 21.918867, rot-vel: 0.637535}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2156.850830, DeltaTheta: -0.033893}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.157
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2150.325195, DeltaTheta: -0.078088}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.150
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.048/NNear + 0.952/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.048] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.048,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.048,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.952] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.952,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.952,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 57.1058
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.145/Forward + 0.855/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.048,Zero),AlgebraicProduct(0.952,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.000953638
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.348/SlowRight + 0.043/VSlowRight + 0.957/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.048,VSlowRight),AlgebraicProduct(0.952,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 57.105841, rot-vel: -0.054639}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2146.370361, DeltaTheta: -0.036574}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.146
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2144.301270, DeltaTheta: 0.012813}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.144
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2139.835938, DeltaTheta: -0.002624}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.140
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2133.170166, DeltaTheta: -0.047681}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.133
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2126.975830, DeltaTheta: -0.024328}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.127
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:14]: {Distance: 2119.891113, DeltaTheta: -0.075416}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.120
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.013/NNear + 0.987/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.013] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.987] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 59.2523
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.037/Forward + 0.963/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.013,Zero),AlgebraicProduct(0.987,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.000243487
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.337/SlowRight + 0.011/VSlowRight + 0.989/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.013,VSlowRight),AlgebraicProduct(0.987,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:14]: {lin-vel: 59.252291, rot-vel: -0.013951}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2112.691650, DeltaTheta: -0.010636}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.113
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2109.097656, DeltaTheta: 0.033370}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.109
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2109.924561, DeltaTheta: 0.157965}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.110
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.979/PNear + 0.021/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.979] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.021] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.53734e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,Zero),AlgebraicProduct(0.021,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0258048
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.323/VSlowLeft + 0.173/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,VSlowLeft),AlgebraicProduct(0.021,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 1.478506}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2114.751221, DeltaTheta: 0.471954}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.115
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.238/PNear + 0.762/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.238] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.762] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.92831e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.238,Zero),AlgebraicProduct(0.762,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0413301
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.517/VSlowLeft + 0.879/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.238,VSlowLeft),AlgebraicProduct(0.762,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 2.368042}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2120.354736, DeltaTheta: 0.463372}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.120
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.258/PNear + 0.742/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.258] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.258,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.258,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.742] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.742,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.742,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.95871e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.258,Zero),AlgebraicProduct(0.742,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0411177
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.514/VSlowLeft + 0.869/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.258,VSlowLeft),AlgebraicProduct(0.742,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 2.355869}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2125.309082, DeltaTheta: 0.516240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.125
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.134/PNear + 0.866/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.134] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.134,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.134,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.866] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.866,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.866,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.2353e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.134,Zero),AlgebraicProduct(0.866,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0423138
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.529/VSlowLeft + 0.923/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.134,VSlowLeft),AlgebraicProduct(0.866,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 2.424400}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2128.337158, DeltaTheta: 0.254240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.128
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.752/PNear + 0.248/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.752] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.248] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.65544e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,Zero),AlgebraicProduct(0.248,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0327882
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.410/VSlowLeft + 0.490/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,VSlowLeft),AlgebraicProduct(0.248,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 1.878623}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2128.040283, DeltaTheta: 0.153736}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.128
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.989/PNear + 0.011/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.989] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.989,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.989,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.011] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.011,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.011,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.13959e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.989,Zero),AlgebraicProduct(0.011,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0254302
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.318/VSlowLeft + 0.156/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.989,VSlowLeft),AlgebraicProduct(0.011,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: 1.457043}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2127.230225, DeltaTheta: 0.053442}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.127
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:15]: {Distance: 2116.152100, DeltaTheta: -0.342444}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.116
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.456/NFar + 0.544/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.456] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.456,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.456,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.544] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.544,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.544,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.1059e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.456,Zero),AlgebraicProduct(0.544,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0264848
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.735/SlowRight + 0.796/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.456,SlowRight),AlgebraicProduct(0.544,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:15]: {lin-vel: -0.000000, rot-vel: -1.517465}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2105.565918, DeltaTheta: -0.490084}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.106
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.805/NFar + 0.195/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.805] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.805,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.805,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.195] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.195,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.195,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.43313e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.805,Zero),AlgebraicProduct(0.195,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0283644
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.763/SlowRight + 0.711/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.805,SlowRight),AlgebraicProduct(0.195,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.625160}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2096.105713, DeltaTheta: -0.628012}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.096
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.096/NVeryFar + 0.904/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.096] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.904] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.62681e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.096,Zero),AlgebraicProduct(0.904,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.03055
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.796/SlowRight + 0.611/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.096,FastRight),AlgebraicProduct(0.904,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.750389}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2089.451904, DeltaTheta: -0.549612}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.089
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.945/NFar + 0.055/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.945] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.945,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.945,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.055] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.055,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.055,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.52311e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.945,Zero),AlgebraicProduct(0.055,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0287708
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.769/SlowRight + 0.692/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.945,SlowRight),AlgebraicProduct(0.055,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.648443}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2085.651855, DeltaTheta: -0.324156}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.413/NFar + 0.587/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.413] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.587] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.677e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.413,Zero),AlgebraicProduct(0.587,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0261456
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.729/SlowRight + 0.812/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.413,SlowRight),AlgebraicProduct(0.587,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.498034}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2085.651855, DeltaTheta: -0.236494}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.206/NFar + 0.794/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.206] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.794] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.01574e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,Zero),AlgebraicProduct(0.794,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0241624
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.699/SlowRight + 0.902/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,SlowRight),AlgebraicProduct(0.794,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: 0.000000, rot-vel: -1.384406}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2080.804199, DeltaTheta: -0.276479}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.081
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.301/NFar + 0.699/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.301] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.301,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.301,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.699] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.699,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.699,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.9709e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.301,Zero),AlgebraicProduct(0.699,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0251397
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.714/SlowRight + 0.857/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.301,SlowRight),AlgebraicProduct(0.699,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.440396}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2073.111572, DeltaTheta: -0.359041}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.073
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.495/NFar + 0.505/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.495] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.495,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.495,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.505] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.505,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.505,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.79782e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.495,Zero),AlgebraicProduct(0.505,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0267705
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.739/SlowRight + 0.783/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.495,SlowRight),AlgebraicProduct(0.505,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.533837}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2070.057373, DeltaTheta: -0.200228}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.070
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.121/NFar + 0.879/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.121] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.879] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.17217e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,Zero),AlgebraicProduct(0.879,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0231799
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.685/SlowRight + 0.946/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,SlowRight),AlgebraicProduct(0.879,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.328109}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2067.966064, DeltaTheta: -0.174696}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.061/NFar + 0.939/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.061] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.061,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.939] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.939,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.73487e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,Zero),AlgebraicProduct(0.939,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0224414
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.673/SlowRight + 0.980/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.061,SlowRight),AlgebraicProduct(0.939,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: -0.000000, rot-vel: -1.285797}
[ DORIS] [2018-03-14 16:29:16]: {Distance: 2066.819092, DeltaTheta: 0.069278}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.067
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:16]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2066.432129, DeltaTheta: 0.083373}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.066
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.881/Zero + 0.119/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.119] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.119,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.119,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.881] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.881,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.881,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.8601
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.357/Forward + 0.643/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.119,Zero),AlgebraicProduct(0.881,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00140148
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.312/SlowRight + 0.000/VSlowRight + 0.936/Zero + 0.018/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.119,VSlowLeft),AlgebraicProduct(0.881,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: 52.860102, rot-vel: 0.080299}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2065.807373, DeltaTheta: 0.165422}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.066
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.961/PNear + 0.039/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.961] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.039] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.48108e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,Zero),AlgebraicProduct(0.039,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0264496
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.331/VSlowLeft + 0.202/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,VSlowLeft),AlgebraicProduct(0.039,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 1.515453}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2063.492432, DeltaTheta: 0.363441}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.063
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.494/PNear + 0.506/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.494] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.494,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.494,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.506] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.506,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.506,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.75761e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.494,Zero),AlgebraicProduct(0.506,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0380049
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.475/VSlowLeft + 0.727/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.494,VSlowLeft),AlgebraicProduct(0.506,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 2.177521}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2063.533691, DeltaTheta: 0.581988}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.064
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.984/PFar + 0.016/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.984] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.016] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.17134e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,Zero),AlgebraicProduct(0.016,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0436569
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.546/VSlowLeft + 0.984/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,SlowLeft),AlgebraicProduct(0.016,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 2.501357}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2064.224365, DeltaTheta: 0.670582}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.064
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.830/PFar + 0.170/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.830] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.170] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.14703e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.830,Zero),AlgebraicProduct(0.170,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0469466
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.866/SlowLeft + 0.134/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.830,SlowLeft),AlgebraicProduct(0.170,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: 0.000000, rot-vel: 2.689841}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2067.801758, DeltaTheta: 0.342551}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.543/PNear + 0.457/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.543] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.543,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.543,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.457] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.457,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.457,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.65143e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.543,Zero),AlgebraicProduct(0.457,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0371777
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.465/VSlowLeft + 0.690/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.543,VSlowLeft),AlgebraicProduct(0.457,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 2.130125}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2074.424072, DeltaTheta: 0.353210}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.074
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.518/PNear + 0.482/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.518] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.518,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.518,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.482] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.482,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.482,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.2069e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.518,Zero),AlgebraicProduct(0.482,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0376086
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.470/VSlowLeft + 0.709/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.518,VSlowLeft),AlgebraicProduct(0.482,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 2.154812}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2081.560547, DeltaTheta: 0.561904}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.026/PNear + 0.974/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.026] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.974] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.65663e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,Zero),AlgebraicProduct(0.974,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0431535
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.539/VSlowLeft + 0.962/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,VSlowLeft),AlgebraicProduct(0.974,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 2.472512}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2076.506836, DeltaTheta: 0.161136}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.077
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.971/PNear + 0.029/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.971] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.029] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.85883e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,Zero),AlgebraicProduct(0.029,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0260814
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.326/VSlowLeft + 0.186/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,VSlowLeft),AlgebraicProduct(0.029,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: -0.000000, rot-vel: 1.494352}
[ DORIS] [2018-03-14 16:29:17]: {Distance: 2071.992188, DeltaTheta: -0.052464}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.072
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:17]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2071.647949, DeltaTheta: -0.234058}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.072
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.201/NFar + 0.799/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.201] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.201,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.201,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.799] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.799,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.799,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.22108e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.201,Zero),AlgebraicProduct(0.799,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0240992
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.698/SlowRight + 0.905/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.201,SlowRight),AlgebraicProduct(0.799,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.380780}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2069.701416, DeltaTheta: -0.242545}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.070
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.221/NFar + 0.779/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.221] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.779] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.779,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.779,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.13496e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.221,Zero),AlgebraicProduct(0.779,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0243178
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.702/SlowRight + 0.895/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.221,SlowRight),AlgebraicProduct(0.779,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.393308}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2065.578613, DeltaTheta: -0.300888}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.066
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.358/NFar + 0.642/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.358] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.358,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.358,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.642] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.642,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.642,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.2422e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.358,Zero),AlgebraicProduct(0.642,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0256767
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.722/SlowRight + 0.833/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.358,SlowRight),AlgebraicProduct(0.642,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.471168}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2063.483643, DeltaTheta: -0.334638}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.063
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.438/NFar + 0.562/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.438] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.438,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.438,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.562] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.562,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.562,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.57214e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.438,Zero),AlgebraicProduct(0.562,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263431
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.732/SlowRight + 0.803/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.438,SlowRight),AlgebraicProduct(0.562,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.509351}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2061.713379, DeltaTheta: -0.272085}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.062
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.290/NFar + 0.710/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.290] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.290,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.290,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.710] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.710,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.710,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.35746e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.290,Zero),AlgebraicProduct(0.710,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0250381
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.713/SlowRight + 0.862/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.290,SlowRight),AlgebraicProduct(0.710,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.434577}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2061.713379, DeltaTheta: -0.272085}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.062
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.290/NFar + 0.710/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.290] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.290,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.290,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.710] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.710,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.710,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.35746e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.290,Zero),AlgebraicProduct(0.710,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0250381
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.713/SlowRight + 0.862/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.290,SlowRight),AlgebraicProduct(0.710,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.434577}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2061.135254, DeltaTheta: -0.199984}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.061
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.120/NFar + 0.880/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.120] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.880] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.05221e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,Zero),AlgebraicProduct(0.880,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.023173
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.947/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,SlowRight),AlgebraicProduct(0.880,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: -0.000000, rot-vel: -1.327714}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2060.692383, DeltaTheta: -0.117232}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.061
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.574/NNear + 0.426/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.574] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.574,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.574,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.426] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.426,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.426,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 25.6123
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.719/MediumForward + 0.281/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.574,Zero),AlgebraicProduct(0.426,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.012578
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.524/SlowRight + 0.572/VSlowRight + 0.428/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.574,VSlowRight),AlgebraicProduct(0.426,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: 25.612314, rot-vel: -0.720667}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2060.692383, DeltaTheta: -0.117232}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.061
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.574/NNear + 0.426/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.574] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.574,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.574,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.426] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.426,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.426,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 25.6123
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.719/MediumForward + 0.281/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.574,Zero),AlgebraicProduct(0.426,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.012578
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.524/SlowRight + 0.572/VSlowRight + 0.428/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.574,VSlowRight),AlgebraicProduct(0.426,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: 25.612314, rot-vel: -0.720667}
[ DORIS] [2018-03-14 16:29:18]: {Distance: 2060.126709, DeltaTheta: -0.115310}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.060
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.548/NNear + 0.452/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.548] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.452] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 27.1608
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.642/MediumForward + 0.358/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.548,Zero),AlgebraicProduct(0.452,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0119877
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.515/SlowRight + 0.545/VSlowRight + 0.455/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.548,VSlowRight),AlgebraicProduct(0.452,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:18]: {lin-vel: 27.160829, rot-vel: -0.686842}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2058.126709, DeltaTheta: 0.059988}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.058
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2054.868652, DeltaTheta: 0.207702}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.055
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.861/PNear + 0.139/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.861] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.861,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.861,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.139] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.139,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.139,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.4739e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.861,Zero),AlgebraicProduct(0.139,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0297546
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.372/VSlowLeft + 0.352/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.861,VSlowLeft),AlgebraicProduct(0.139,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: 1.704815}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2051.635010, DeltaTheta: 0.279934}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.052
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.691/PNear + 0.309/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.691] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.309] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.98145e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.691,Zero),AlgebraicProduct(0.309,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0342318
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.428/VSlowLeft + 0.556/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.691,VSlowLeft),AlgebraicProduct(0.309,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: 1.961340}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2043.420654, DeltaTheta: 0.210972}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.043
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.854/PNear + 0.146/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.854] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.146] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.27563e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.854,Zero),AlgebraicProduct(0.146,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0299871
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.375/VSlowLeft + 0.363/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.854,VSlowLeft),AlgebraicProduct(0.146,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: 1.718135}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2044.963745, DeltaTheta: 0.171659}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.045
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.946/PNear + 0.054/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.946] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.946,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.946,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.054] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.054,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.054,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.61836e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.946,Zero),AlgebraicProduct(0.054,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.026974
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.337/VSlowLeft + 0.226/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.946,VSlowLeft),AlgebraicProduct(0.054,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: 1.545497}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2048.910156, DeltaTheta: 0.014905}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.049
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2052.647949, DeltaTheta: 0.061916}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.053
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2047.563843, DeltaTheta: -0.020322}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.048
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2042.035889, DeltaTheta: -0.181362}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.042
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.076/NFar + 0.924/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.076] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.076,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.076,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.924] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.924,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.924,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.9653e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.076,Zero),AlgebraicProduct(0.924,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0226374
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.676/SlowRight + 0.971/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.076,SlowRight),AlgebraicProduct(0.924,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: -1.297030}
[ DORIS] [2018-03-14 16:29:19]: {Distance: 2035.953125, DeltaTheta: -0.269697}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.036
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.285/NFar + 0.715/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.285] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.285,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.285,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.715] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.715,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.715,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.74667e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.285,Zero),AlgebraicProduct(0.715,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0249823
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.712/SlowRight + 0.864/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.285,SlowRight),AlgebraicProduct(0.715,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:19]: {lin-vel: -0.000000, rot-vel: -1.431380}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2027.721191, DeltaTheta: -0.397287}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.028
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.586/NFar + 0.414/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.586] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.586,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.586,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.414] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.414,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.414,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.19829e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.586,Zero),AlgebraicProduct(0.414,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.027352
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.748/SlowRight + 0.757/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.586,SlowRight),AlgebraicProduct(0.414,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: -0.000000, rot-vel: -1.567152}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2025.270752, DeltaTheta: -0.264912}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.025
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.273/NFar + 0.727/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.273] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.273,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.273,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.727] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.727,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.727,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.10562e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.273,Zero),AlgebraicProduct(0.727,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0248692
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.710/SlowRight + 0.870/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.273,SlowRight),AlgebraicProduct(0.727,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: -0.000000, rot-vel: -1.424898}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2027.580200, DeltaTheta: -0.071240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.028
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2025.675659, DeltaTheta: -0.111795}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.026
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.501/NNear + 0.499/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.501] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.501,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.501,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.499] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.499,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.499,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 29.9927
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.500/MediumForward + 0.500/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.501,Zero),AlgebraicProduct(0.499,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0109047
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.499/SlowRight + 0.496/VSlowRight + 0.504/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.501,VSlowRight),AlgebraicProduct(0.499,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 29.992738, rot-vel: -0.624793}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2023.652710, DeltaTheta: -0.096423}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.024
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.295/NNear + 0.705/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.295] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.295,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.295,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.705] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.705,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.705,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 42.368
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.882/Forward + 0.118/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.295,Zero),AlgebraicProduct(0.705,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00620216
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.427/SlowRight + 0.282/VSlowRight + 0.718/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.295,VSlowRight),AlgebraicProduct(0.705,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 42.368017, rot-vel: -0.355357}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2020.477661, DeltaTheta: -0.062820}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.020
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2016.354492, DeltaTheta: 0.024804}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.016
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2008.364624, DeltaTheta: 0.001830}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.008
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 2001.121216, DeltaTheta: 0.094236}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 2.001
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.735/Zero + 0.265/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.265] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.265,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.265,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.735] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.735,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.735,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.1264
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.794/Forward + 0.206/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.265,Zero),AlgebraicProduct(0.735,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00345514
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.281/SlowRight + 0.000/VSlowRight + 0.843/Zero + 0.043/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.265,VSlowLeft),AlgebraicProduct(0.735,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 44.126449, rot-vel: 0.197965}
[ DORIS] [2018-03-14 16:29:20]: {Distance: 1995.038452, DeltaTheta: 0.094524}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.995
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.731/Zero + 0.269/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.269] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.269,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.269,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.731] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.731,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.731,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 43.8953
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.805/Forward + 0.195/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.269,Zero),AlgebraicProduct(0.731,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00351533
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.280/SlowRight + 0.000/VSlowRight + 0.840/Zero + 0.044/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.269,VSlowLeft),AlgebraicProduct(0.731,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:20]: {lin-vel: 43.895344, rot-vel: 0.201414}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1994.526489, DeltaTheta: 0.281835}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.995
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.687/PNear + 0.313/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.687] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.687,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.687,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.313] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.313,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.313,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.49684e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.687,Zero),AlgebraicProduct(0.313,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0343327
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.429/VSlowLeft + 0.561/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.687,VSlowLeft),AlgebraicProduct(0.313,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: -0.000000, rot-vel: 1.967121}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1995.157349, DeltaTheta: 0.478537}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.995
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.223/PNear + 0.777/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.223] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.223,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.223,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.777] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.777,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.777,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.3741e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.223,Zero),AlgebraicProduct(0.777,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.041488
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.519/VSlowLeft + 0.886/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.223,VSlowLeft),AlgebraicProduct(0.777,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: -0.000000, rot-vel: 2.377090}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1992.327393, DeltaTheta: 0.392743}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.992
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.425/PNear + 0.575/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.425] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.425,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.425,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.575] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.575,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.575,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.11415e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.425,Zero),AlgebraicProduct(0.575,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0390528
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.488/VSlowLeft + 0.775/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.425,VSlowLeft),AlgebraicProduct(0.575,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: -0.000000, rot-vel: 2.237559}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1990.445312, DeltaTheta: 0.161767}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.990
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.970/PNear + 0.030/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.970] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.030] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.40982e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.970,Zero),AlgebraicProduct(0.030,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.026136
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.327/VSlowLeft + 0.188/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.970,VSlowLeft),AlgebraicProduct(0.030,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: -0.000000, rot-vel: 1.497485}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1990.445312, DeltaTheta: 0.074105}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.990
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1990.451904, DeltaTheta: 0.014646}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.990
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1988.999268, DeltaTheta: -0.021717}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.989
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1985.837036, DeltaTheta: -0.109484}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.986
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.470/NNear + 0.530/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.470] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.530] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 31.8546
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.407/MediumForward + 0.593/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,Zero),AlgebraicProduct(0.530,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0101918
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.488/SlowRight + 0.463/VSlowRight + 0.537/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,VSlowRight),AlgebraicProduct(0.530,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 31.854567, rot-vel: -0.583944}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1980.414429, DeltaTheta: -0.135047}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.980
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.813/NNear + 0.187/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.813] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.187] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.2437
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.146/Backwards + 0.000/MediumBackwards + 0.438/Zero + 0.562/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.813,Zero),AlgebraicProduct(0.187,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0178895
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.604/SlowRight + 0.813/VSlowRight + 0.187/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.813,VSlowRight),AlgebraicProduct(0.187,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 11.243727, rot-vel: -1.024992}
[ DORIS] [2018-03-14 16:29:21]: {Distance: 1973.343384, DeltaTheta: -0.223351}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.973
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.175/NFar + 0.825/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.175] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.175,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.825] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.825,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.88236e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.175,Zero),AlgebraicProduct(0.825,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0238162
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.694/SlowRight + 0.917/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.175,SlowRight),AlgebraicProduct(0.825,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:21]: {lin-vel: 0.000000, rot-vel: -1.364570}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1968.400635, DeltaTheta: -0.198784}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.968
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.117/NFar + 0.883/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.117] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.117,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.117,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.883] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.883,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.883,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.16185e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.117,Zero),AlgebraicProduct(0.883,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.023139
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.948/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.117,SlowRight),AlgebraicProduct(0.883,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: -0.000000, rot-vel: -1.325769}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1967.400635, DeltaTheta: 0.064170}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.967
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1968.517578, DeltaTheta: 0.082407}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.969
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.894/Zero + 0.106/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.106] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.106,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.106,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.894] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.894,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.894,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 53.6367
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.318/Forward + 0.682/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.106,Zero),AlgebraicProduct(0.894,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00123797
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.315/SlowRight + 0.000/VSlowRight + 0.944/Zero + 0.015/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.106,VSlowLeft),AlgebraicProduct(0.894,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 53.636675, rot-vel: 0.070930}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1968.576416, DeltaTheta: 0.124200}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.969
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.333/Zero + 0.667/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.667] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.333] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 19.9952
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 1.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,Zero),AlgebraicProduct(0.333,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0120227
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.151/SlowRight + 0.000/VSlowRight + 0.454/Zero + 0.150/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,VSlowLeft),AlgebraicProduct(0.333,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 19.995163, rot-vel: 0.688850}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1967.576538, DeltaTheta: 0.124263}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.968
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.332/Zero + 0.668/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.668] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.668,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.668,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.332] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.332,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.332,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 19.9443
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.003/Zero + 0.997/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.668,Zero),AlgebraicProduct(0.332,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.012047
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.151/SlowRight + 0.000/VSlowRight + 0.452/Zero + 0.151/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.668,VSlowLeft),AlgebraicProduct(0.332,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 19.944262, rot-vel: 0.690245}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1960.778198, DeltaTheta: 0.132847}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.961
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.216/Zero + 0.784/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.784] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.216] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 13.0193
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.116/Backwards + 0.000/MediumBackwards + 0.349/Zero + 0.651/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.784,Zero),AlgebraicProduct(0.216,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0157038
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.095/SlowRight + 0.000/VSlowRight + 0.286/Zero + 0.196/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.784,VSlowLeft),AlgebraicProduct(0.216,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 13.019273, rot-vel: 0.899761}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1955.679199, DeltaTheta: 0.133194}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.956
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.212/Zero + 0.788/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.788] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.788,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.788,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.212] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.212,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.212,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 12.7397
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.121/Backwards + 0.000/MediumBackwards + 0.363/Zero + 0.637/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.788,Zero),AlgebraicProduct(0.212,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0158671
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.093/SlowRight + 0.000/VSlowRight + 0.279/Zero + 0.198/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.788,VSlowLeft),AlgebraicProduct(0.212,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 12.739743, rot-vel: 0.909119}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1952.800049, DeltaTheta: 0.072097}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.953
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1955.001221, DeltaTheta: 0.003975}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.955
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:22]: {Distance: 1954.001221, DeltaTheta: 0.003977}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.954
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:22]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1950.896729, DeltaTheta: -0.001477}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.951
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1944.341309, DeltaTheta: -0.039755}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.944
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1935.286011, DeltaTheta: -0.127808}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.935
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.716/NNear + 0.284/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.716] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.716,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.716,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.284] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.284,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.284,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 17.0847
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.049/Backwards + 0.000/MediumBackwards + 0.146/Zero + 0.854/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.716,Zero),AlgebraicProduct(0.284,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0157784
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.572/SlowRight + 0.717/VSlowRight + 0.283/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.716,VSlowRight),AlgebraicProduct(0.284,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 17.084658, rot-vel: -0.904037}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1927.151001, DeltaTheta: -0.254138}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.927
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.248/NFar + 0.752/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.248] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.752] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.20642e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.248,Zero),AlgebraicProduct(0.752,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0246082
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.706/SlowRight + 0.881/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.248,SlowRight),AlgebraicProduct(0.752,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 0.000000, rot-vel: -1.409944}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1920.955688, DeltaTheta: -0.095859}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.921
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.287/NNear + 0.713/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.287] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.713] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.713,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.713,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 42.8212
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.859/Forward + 0.141/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.287,Zero),AlgebraicProduct(0.713,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00603317
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.425/SlowRight + 0.274/VSlowRight + 0.726/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.287,VSlowRight),AlgebraicProduct(0.713,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 42.821174, rot-vel: -0.345675}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1919.955688, DeltaTheta: 0.167147}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.920
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.957/PNear + 0.043/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.957] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.957,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.957,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.043] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.043,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.043,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.82342e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.957,Zero),AlgebraicProduct(0.043,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.026596
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.332/VSlowLeft + 0.209/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.957,VSlowLeft),AlgebraicProduct(0.043,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 0.000000, rot-vel: 1.523838}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1919.877075, DeltaTheta: 0.121598}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.920
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.367/Zero + 0.633/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.633] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.633,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.633,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.367] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.367,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.367,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.0933
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.895/MediumForward + 0.105/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.633,Zero),AlgebraicProduct(0.367,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0110482
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.166/SlowRight + 0.000/VSlowRight + 0.498/Zero + 0.138/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.633,VSlowLeft),AlgebraicProduct(0.367,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 22.093252, rot-vel: 0.633014}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1919.877075, DeltaTheta: 0.033935}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.920
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1918.380493, DeltaTheta: 0.040660}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.918
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:23]: {Distance: 1913.867188, DeltaTheta: 0.022897}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.914
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1907.784424, DeltaTheta: -0.064832}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.908
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1900.778320, DeltaTheta: -0.010783}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.901
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1893.529785, DeltaTheta: -0.034231}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.894
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1887.447021, DeltaTheta: -0.034341}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.887
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1882.574951, DeltaTheta: 0.013497}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.883
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1880.261230, DeltaTheta: 0.105980}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.880
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.577/Zero + 0.423/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.423] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.423,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.423,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.577] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.577,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.577,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 34.6763
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.266/MediumForward + 0.734/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.423,Zero),AlgebraicProduct(0.577,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00620945
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.239/SlowRight + 0.000/VSlowRight + 0.718/Zero + 0.078/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.423,VSlowLeft),AlgebraicProduct(0.577,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 34.676342, rot-vel: 0.355775}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1872.236694, DeltaTheta: -0.001184}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.872
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1867.212402, DeltaTheta: 0.081756}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.867
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.902/Zero + 0.098/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.098] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.902] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.1594
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.292/Forward + 0.708/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,Zero),AlgebraicProduct(0.902,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0011295
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.316/SlowRight + 0.000/VSlowRight + 0.949/Zero + 0.014/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,VSlowLeft),AlgebraicProduct(0.902,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 54.159441, rot-vel: 0.064715}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1864.075195, DeltaTheta: 0.119824}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.864
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.391/Zero + 0.609/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.609] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.391] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.5233
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.824/MediumForward + 0.176/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,Zero),AlgebraicProduct(0.391,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0104149
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.176/SlowRight + 0.000/VSlowRight + 0.527/Zero + 0.130/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,VSlowLeft),AlgebraicProduct(0.391,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 23.523264, rot-vel: 0.596732}
[ DORIS] [2018-03-14 16:29:24]: {Distance: 1858.336426, DeltaTheta: 0.134734}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.858
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.191/Zero + 0.809/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.809] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.809,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.809,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.191] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.191,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.191,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.4964
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.142/Backwards + 0.000/MediumBackwards + 0.425/Zero + 0.575/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.809,Zero),AlgebraicProduct(0.191,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.01661
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.082/SlowRight + 0.000/VSlowRight + 0.245/Zero + 0.208/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.809,VSlowLeft),AlgebraicProduct(0.191,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:24]: {lin-vel: 11.496445, rot-vel: 0.951683}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1853.776611, DeltaTheta: 0.209897}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.854
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.856/PNear + 0.144/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.856] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.856,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.856,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.144] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.144,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.144,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.54105e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.856,Zero),AlgebraicProduct(0.144,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.029911
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.374/VSlowLeft + 0.360/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.856,VSlowLeft),AlgebraicProduct(0.144,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: -0.000000, rot-vel: 1.713776}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1850.776611, DeltaTheta: 0.210237}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.851
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.855/PNear + 0.145/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.855] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.855,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.855,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.145] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.145,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.145,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.49349e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.855,Zero),AlgebraicProduct(0.145,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0299352
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.374/VSlowLeft + 0.361/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.855,VSlowLeft),AlgebraicProduct(0.145,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: -0.000000, rot-vel: 1.715158}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1848.435303, DeltaTheta: -0.002547}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.848
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1849.435303, DeltaTheta: -0.002545}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.849
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1848.931641, DeltaTheta: -0.100095}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.849
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.344/NNear + 0.656/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.344] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.344,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.344,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.656] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.656,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.656,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 39.4133
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.029/MediumForward + 0.971/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.344,Zero),AlgebraicProduct(0.656,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00731188
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.444/SlowRight + 0.332/VSlowRight + 0.668/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.344,VSlowRight),AlgebraicProduct(0.656,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 39.413319, rot-vel: -0.418940}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1845.646484, DeltaTheta: -0.096578}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.846
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.297/NNear + 0.703/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.297] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.297,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.297,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.703] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.703,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.703,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 42.2427
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.888/Forward + 0.112/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.297,Zero),AlgebraicProduct(0.703,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00624895
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.428/SlowRight + 0.284/VSlowRight + 0.716/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.297,VSlowRight),AlgebraicProduct(0.703,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 42.242697, rot-vel: -0.358038}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1839.646484, DeltaTheta: -0.096893}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.840
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.301/NNear + 0.699/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.301] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.301,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.301,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.699] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.699,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.699,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 41.9893
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.901/Forward + 0.099/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.301,Zero),AlgebraicProduct(0.699,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00634365
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.429/SlowRight + 0.288/VSlowRight + 0.712/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.301,VSlowRight),AlgebraicProduct(0.699,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 41.989290, rot-vel: -0.363464}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1834.994995, DeltaTheta: -0.078378}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.835
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.052/NNear + 0.948/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.052] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.948] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.8732
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.156/Forward + 0.844/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.052,Zero),AlgebraicProduct(0.948,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00103158
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.349/SlowRight + 0.047/VSlowRight + 0.953/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.052,VSlowRight),AlgebraicProduct(0.948,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 56.873195, rot-vel: -0.059105}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1832.036011, DeltaTheta: -0.042240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.832
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:25]: {Distance: 1829.481812, DeltaTheta: -0.143306}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.829
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.924/NNear + 0.076/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.924] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.924,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.924,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.076] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.076,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.076,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.57528
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.257/Backwards + 0.000/MediumBackwards + 0.771/Zero + 0.229/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.924,Zero),AlgebraicProduct(0.076,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0201819
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.639/SlowRight + 0.917/VSlowRight + 0.083/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.924,VSlowRight),AlgebraicProduct(0.076,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:25]: {lin-vel: 4.575280, rot-vel: -1.156339}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1826.847290, DeltaTheta: -0.128944}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.827
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.731/NNear + 0.269/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.731] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.731,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.731,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.269] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.269,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.269,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 16.1685
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.064/Backwards + 0.000/MediumBackwards + 0.192/Zero + 0.808/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.731,Zero),AlgebraicProduct(0.269,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0161149
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.577/SlowRight + 0.732/VSlowRight + 0.268/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.731,VSlowRight),AlgebraicProduct(0.269,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 16.168461, rot-vel: -0.923314}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1825.580078, DeltaTheta: -0.074375}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.826
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1822.004883, DeltaTheta: -0.224384}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.822
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.178/NFar + 0.822/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.178] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.178,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.178,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.822] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.822,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.822,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.70119e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.178,Zero),AlgebraicProduct(0.822,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0238439
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.695/SlowRight + 0.916/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.178,SlowRight),AlgebraicProduct(0.822,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: -0.000000, rot-vel: -1.366153}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1819.768799, DeltaTheta: 0.038490}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.820
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1815.656738, DeltaTheta: 0.022531}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.816
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1806.848633, DeltaTheta: -0.097835}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.807
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.313/NNear + 0.687/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.313] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.313,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.313,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.687] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.687,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.687,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 41.2318
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.938/Forward + 0.062/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.313,Zero),AlgebraicProduct(0.687,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00662737
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.434/SlowRight + 0.301/VSlowRight + 0.699/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.313,VSlowRight),AlgebraicProduct(0.687,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 41.231766, rot-vel: -0.379720}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1801.604980, DeltaTheta: -0.107071}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.802
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.437/NNear + 0.563/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.437] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.563] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.7979
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.310/MediumForward + 0.690/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,Zero),AlgebraicProduct(0.563,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00944807
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.476/SlowRight + 0.429/VSlowRight + 0.571/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,VSlowRight),AlgebraicProduct(0.563,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 33.797858, rot-vel: -0.541335}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1795.673828, DeltaTheta: 0.018940}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.796
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1791.550659, DeltaTheta: 0.106747}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.792
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.567/Zero + 0.433/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.433] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.433,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.433,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.567] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.567,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.567,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 34.0583
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.297/MediumForward + 0.703/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.433,Zero),AlgebraicProduct(0.567,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00641263
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.236/SlowRight + 0.000/VSlowRight + 0.709/Zero + 0.080/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.433,VSlowLeft),AlgebraicProduct(0.567,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 34.058332, rot-vel: 0.367416}
[ DORIS] [2018-03-14 16:29:26]: {Distance: 1786.538452, DeltaTheta: 0.065069}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.787
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:26]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1780.722412, DeltaTheta: 0.175968}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.781
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.936/PNear + 0.064/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.49916e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,Zero),AlgebraicProduct(0.064,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0273285
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.342/VSlowLeft + 0.242/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,VSlowLeft),AlgebraicProduct(0.064,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: -0.000000, rot-vel: 1.565806}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1777.722534, DeltaTheta: 0.176265}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.778
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.936/PNear + 0.064/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.96777e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,Zero),AlgebraicProduct(0.064,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0273527
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.342/VSlowLeft + 0.243/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,VSlowLeft),AlgebraicProduct(0.064,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: -0.000000, rot-vel: 1.567192}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1772.138184, DeltaTheta: 0.178637}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.772
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.930/PNear + 0.070/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.930] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.070] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.23452e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,Zero),AlgebraicProduct(0.070,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0275449
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.344/VSlowLeft + 0.252/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,VSlowLeft),AlgebraicProduct(0.070,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: -0.000000, rot-vel: 1.578209}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1771.138184, DeltaTheta: 0.091051}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.771
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.778/Zero + 0.222/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.222] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.778] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.6883
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.666/Forward + 0.334/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.222,Zero),AlgebraicProduct(0.778,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00280922
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.291/SlowRight + 0.000/VSlowRight + 0.872/Zero + 0.035/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.222,VSlowLeft),AlgebraicProduct(0.778,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 46.688279, rot-vel: 0.160956}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1768.526733, DeltaTheta: -0.178010}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.769
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.068/NFar + 0.932/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.068] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.932] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.10885e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.068,Zero),AlgebraicProduct(0.932,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0225391
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.675/SlowRight + 0.975/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.068,SlowRight),AlgebraicProduct(0.932,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 0.000000, rot-vel: -1.291397}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1767.286987, DeltaTheta: -0.207793}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.767
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.139/NFar + 0.861/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.139] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.139,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.139,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.861] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.861,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.861,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.23083e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.139,Zero),AlgebraicProduct(0.861,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0233917
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.688/SlowRight + 0.937/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.139,SlowRight),AlgebraicProduct(0.861,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: -0.000000, rot-vel: -1.340245}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1766.286987, DeltaTheta: -0.120223}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.766
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.614/NNear + 0.386/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.614] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.614,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.614,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.386] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.386,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.386,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.2016
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.840/MediumForward + 0.160/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.614,Zero),AlgebraicProduct(0.386,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0134929
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.538/SlowRight + 0.613/VSlowRight + 0.387/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.614,VSlowRight),AlgebraicProduct(0.386,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 23.201638, rot-vel: -0.773084}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1764.264648, DeltaTheta: -0.074480}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.764
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar - 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1763.264648, DeltaTheta: 0.013165}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.763
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:27]: {Distance: 1760.145386, DeltaTheta: -0.025359}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.760
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:27]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1755.600220, DeltaTheta: -0.034557}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.756
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1748.529175, DeltaTheta: 0.053143}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.749
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1740.586792, DeltaTheta: -0.053773}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.741
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1733.276611, DeltaTheta: -0.137149}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.733
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.841/NNear + 0.159/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.841] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.841,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.841,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.159] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.159,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.159,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 9.54693
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.174/Backwards + 0.000/MediumBackwards + 0.523/Zero + 0.477/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.841,Zero),AlgebraicProduct(0.159,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0184859
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.613/SlowRight + 0.840/VSlowRight + 0.160/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.841,VSlowRight),AlgebraicProduct(0.159,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 9.546928, rot-vel: -1.059165}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1727.193848, DeltaTheta: -0.225449}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.727
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.180/NFar + 0.820/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.180] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.820] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.32389e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,Zero),AlgebraicProduct(0.820,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0238723
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.695/SlowRight + 0.915/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,SlowRight),AlgebraicProduct(0.820,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: -0.000000, rot-vel: -1.367782}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1723.133911, DeltaTheta: -0.142004}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.723
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.906/NNear + 0.094/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.906] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.906,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.906,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.094] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.094,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.094,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.62727
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.240/Backwards + 0.000/MediumBackwards + 0.719/Zero + 0.281/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.906,Zero),AlgebraicProduct(0.094,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0198299
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.634/SlowRight + 0.901/VSlowRight + 0.099/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.906,VSlowRight),AlgebraicProduct(0.094,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 5.627267, rot-vel: -1.136168}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1722.133911, DeltaTheta: 0.120978}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.722
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.376/Zero + 0.624/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.624] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.376] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.5928
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.870/MediumForward + 0.130/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,Zero),AlgebraicProduct(0.376,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0108242
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.169/SlowRight + 0.000/VSlowRight + 0.508/Zero + 0.135/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,VSlowLeft),AlgebraicProduct(0.376,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 22.592842, rot-vel: 0.620180}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1723.412964, DeltaTheta: 0.177511}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.723
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.933/PNear + 0.067/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.933] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.933,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.933,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.067] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.067,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.067,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.81097e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.933,Zero),AlgebraicProduct(0.067,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0274539
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.343/VSlowLeft + 0.248/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.933,VSlowLeft),AlgebraicProduct(0.067,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: 0.000000, rot-vel: 1.572994}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1721.617188, DeltaTheta: 0.213243}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.722
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.848/PNear + 0.152/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.848] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.152] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.32378e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.848,Zero),AlgebraicProduct(0.152,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0301468
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.377/VSlowLeft + 0.370/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.848,VSlowLeft),AlgebraicProduct(0.152,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: -0.000000, rot-vel: 1.727283}
[ DORIS] [2018-03-14 16:29:28]: {Distance: 1721.617188, DeltaTheta: 0.213243}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.722
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.848/PNear + 0.152/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.848] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.152] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.32378e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.848,Zero),AlgebraicProduct(0.152,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0301468
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.377/VSlowLeft + 0.370/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.848,VSlowLeft),AlgebraicProduct(0.152,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:28]: {lin-vel: -0.000000, rot-vel: 1.727283}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1720.707764, DeltaTheta: 0.159688}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.721
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.975/PNear + 0.025/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.975] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.025] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.82697e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.975,Zero),AlgebraicProduct(0.025,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0259555
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.324/VSlowLeft + 0.180/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.975,VSlowLeft),AlgebraicProduct(0.025,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: -0.000000, rot-vel: 1.487142}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1718.713623, DeltaTheta: 0.010885}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.719
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1718.713623, DeltaTheta: -0.164440}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.719
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.036/NFar + 0.964/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.036] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.036,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.036,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.964] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.964,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.964,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.9309e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.036,Zero),AlgebraicProduct(0.964,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0221357
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.669/SlowRight + 0.994/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.036,SlowRight),AlgebraicProduct(0.964,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 0.000000, rot-vel: -1.268285}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1717.380737, DeltaTheta: -0.177532}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.717
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.067/NFar + 0.933/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.067] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.067,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.067,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.933] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.933,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.933,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.44258e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.067,Zero),AlgebraicProduct(0.933,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0225251
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.675/SlowRight + 0.976/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.067,SlowRight),AlgebraicProduct(0.933,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: -0.000000, rot-vel: -1.290591}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1715.261719, DeltaTheta: -0.124026}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.715
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.665/NNear + 0.335/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.665] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.665,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.665,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.335] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.335,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.335,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.1355
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.993/MediumForward + 0.007/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.665,Zero),AlgebraicProduct(0.335,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0146462
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.555/SlowRight + 0.666/VSlowRight + 0.334/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.665,VSlowRight),AlgebraicProduct(0.335,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 20.135476, rot-vel: -0.839164}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1714.261719, DeltaTheta: -0.124098}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.714
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.666/NNear + 0.334/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.666] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.334] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.0771
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.996/MediumForward + 0.004/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,Zero),AlgebraicProduct(0.334,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.014668
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.556/SlowRight + 0.667/VSlowRight + 0.333/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,VSlowRight),AlgebraicProduct(0.334,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 20.077137, rot-vel: -0.840413}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1713.181763, DeltaTheta: -0.139883}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.713
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.878/NNear + 0.122/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.878] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.878,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.878,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.122] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.122,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.122,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.33973
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.211/Backwards + 0.000/MediumBackwards + 0.633/Zero + 0.367/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.878,Zero),AlgebraicProduct(0.122,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0192488
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.625/SlowRight + 0.875/VSlowRight + 0.125/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.878,VSlowRight),AlgebraicProduct(0.122,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 7.339731, rot-vel: -1.102874}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1710.945801, DeltaTheta: -0.140066}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.711
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.880/NNear + 0.120/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.880] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.120] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.1921
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.213/Backwards + 0.000/MediumBackwards + 0.640/Zero + 0.360/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.880,Zero),AlgebraicProduct(0.120,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0192993
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.626/SlowRight + 0.877/VSlowRight + 0.123/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.880,VSlowRight),AlgebraicProduct(0.120,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 7.192103, rot-vel: -1.105766}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1710.928345, DeltaTheta: -0.030868}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.711
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:29]: {Distance: 1709.928345, DeltaTheta: 0.056802}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.710
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:29]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1707.788818, DeltaTheta: -0.036570}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.708
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1705.524902, DeltaTheta: 0.154343}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.706
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.987/PNear + 0.013/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.987] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.013] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.10161e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,Zero),AlgebraicProduct(0.013,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0254843
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.319/VSlowLeft + 0.158/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,VSlowLeft),AlgebraicProduct(0.013,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: -0.000000, rot-vel: 1.460145}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1699.524902, DeltaTheta: 0.330523}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.700
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.572/PNear + 0.428/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.572] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.572,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.572,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.428] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.428,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.428,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.95654e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.572,Zero),AlgebraicProduct(0.428,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0366685
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.458/VSlowLeft + 0.667/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.572,VSlowLeft),AlgebraicProduct(0.428,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: -0.000000, rot-vel: 2.100950}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1692.868408, DeltaTheta: 0.291440}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.693
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.664/PNear + 0.336/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.664] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.664,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.664,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.336] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.336,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.336,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.05067e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.664,Zero),AlgebraicProduct(0.336,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0348309
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.435/VSlowLeft + 0.583/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.664,VSlowLeft),AlgebraicProduct(0.336,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: -0.000000, rot-vel: 1.995665}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1689.706177, DeltaTheta: 0.116497}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.690
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.436/Zero + 0.564/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.564] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.564,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.564,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.436] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.436,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.436,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 26.205
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.690/MediumForward + 0.310/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.564,Zero),AlgebraicProduct(0.436,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00929044
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.193/SlowRight + 0.000/VSlowRight + 0.578/Zero + 0.116/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.564,VSlowLeft),AlgebraicProduct(0.436,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 26.204980, rot-vel: 0.532303}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1689.344604, DeltaTheta: -0.026941}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.689
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1688.887817, DeltaTheta: -0.220377}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.689
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.168/NFar + 0.832/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.168] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.832] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.68493e-18
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.168,Zero),AlgebraicProduct(0.832,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0237363
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.693/SlowRight + 0.921/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.168,SlowRight),AlgebraicProduct(0.832,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 0.000000, rot-vel: -1.359990}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1687.887817, DeltaTheta: -0.220508}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.688
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.169/NFar + 0.831/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.169] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.169,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.169,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.831] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.831,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.831,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.54484e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.169,Zero),AlgebraicProduct(0.831,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0237398
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.693/SlowRight + 0.921/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.169,SlowRight),AlgebraicProduct(0.831,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 0.000000, rot-vel: -1.360191}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1682.888184, DeltaTheta: -0.133070}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.683
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.787/NNear + 0.213/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.787] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.213] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 12.8394
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.119/Backwards + 0.000/MediumBackwards + 0.358/Zero + 0.642/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.787,Zero),AlgebraicProduct(0.213,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0173212
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.596/SlowRight + 0.787/VSlowRight + 0.213/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.787,VSlowRight),AlgebraicProduct(0.213,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: 12.839386, rot-vel: -0.992433}
[ DORIS] [2018-03-14 16:29:30]: {Distance: 1678.765137, DeltaTheta: -0.221167}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.679
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.170/NFar + 0.830/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.170] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.830] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.35308e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,Zero),AlgebraicProduct(0.830,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0237576
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.693/SlowRight + 0.920/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,SlowRight),AlgebraicProduct(0.830,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:30]: {lin-vel: -0.000000, rot-vel: -1.361210}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1676.513672, DeltaTheta: -0.119832}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.677
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.609/NNear + 0.391/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.609] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.391] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.5165
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.824/MediumForward + 0.176/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,Zero),AlgebraicProduct(0.391,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0133737
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.536/SlowRight + 0.608/VSlowRight + 0.392/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,VSlowRight),AlgebraicProduct(0.391,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 23.516514, rot-vel: -0.766258}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1676.978882, DeltaTheta: 0.098328}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.677
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.680/Zero + 0.320/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.320] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.680] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.8351
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.958/Forward + 0.042/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.320,Zero),AlgebraicProduct(0.680,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00434427
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.268/SlowRight + 0.000/VSlowRight + 0.803/Zero + 0.054/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.320,VSlowLeft),AlgebraicProduct(0.680,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 40.835129, rot-vel: 0.248908}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1677.978882, DeltaTheta: 0.010633}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.678
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1677.213135, DeltaTheta: 0.059938}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.677
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1673.090088, DeltaTheta: 0.235627}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.673
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.796/PNear + 0.204/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.796] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.796,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.796,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.204] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.204,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.204,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.08878e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.796,Zero),AlgebraicProduct(0.204,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0316436
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.396/VSlowLeft + 0.438/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.796,VSlowLeft),AlgebraicProduct(0.204,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: -0.000000, rot-vel: 1.813047}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1667.721924, DeltaTheta: 0.182130}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.668
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.922/PNear + 0.078/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.922] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.922,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.922,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.078] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.078,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.078,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.46283e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.922,Zero),AlgebraicProduct(0.078,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0278246
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.348/VSlowLeft + 0.265/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.922,VSlowLeft),AlgebraicProduct(0.078,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: -0.000000, rot-vel: 1.594231}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1662.921387, DeltaTheta: 0.218354}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.663
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.836/PNear + 0.164/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.836] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.836,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.836,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.164] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.164,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.164,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.14269e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.836,Zero),AlgebraicProduct(0.164,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0305007
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.381/VSlowLeft + 0.386/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.836,VSlowLeft),AlgebraicProduct(0.164,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: -0.000000, rot-vel: 1.747563}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1658.921387, DeltaTheta: -0.044425}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.659
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1661.030273, DeltaTheta: -0.058995}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.661
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:31]: {Distance: 1662.453613, DeltaTheta: -0.334932}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.662
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.439/NFar + 0.561/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.439] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.439,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.439,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.561] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.561,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.561,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 8.82008e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.439,Zero),AlgebraicProduct(0.561,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263486
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.733/SlowRight + 0.802/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.439,SlowRight),AlgebraicProduct(0.561,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:31]: {lin-vel: 0.000000, rot-vel: -1.509662}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1662.453613, DeltaTheta: -0.159607}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.662
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.025/NFar + 0.975/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.025] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.975] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.02257e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.025,Zero),AlgebraicProduct(0.975,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0219902
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.667/SlowRight + 1.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.025,SlowRight),AlgebraicProduct(0.975,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: -0.000000, rot-vel: -1.259944}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1657.608032, DeltaTheta: -0.073758}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.658
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1653.776489, DeltaTheta: -0.091811}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.654
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.233/NNear + 0.767/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.233] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.233,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.233,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.767] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.767,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.767,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.0775
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.696/Forward + 0.304/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.233,Zero),AlgebraicProduct(0.767,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00483021
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.407/SlowRight + 0.220/VSlowRight + 0.780/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.233,VSlowRight),AlgebraicProduct(0.767,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 46.077478, rot-vel: -0.276751}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1650.614258, DeltaTheta: -0.004240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.651
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1649.609741, DeltaTheta: -0.002083}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.650
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1646.588257, DeltaTheta: -0.056125}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.647
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1641.489258, DeltaTheta: 0.031500}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.641
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1631.266602, DeltaTheta: 0.221804}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.631
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.828/PNear + 0.172/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.828] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.828,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.828,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.172] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.172,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.172,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.09195e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.828,Zero),AlgebraicProduct(0.172,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0307355
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.384/VSlowLeft + 0.397/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.828,VSlowLeft),AlgebraicProduct(0.172,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: -0.000000, rot-vel: 1.761014}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1618.838013, DeltaTheta: 0.394673}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.619
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.420/PNear + 0.580/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.420] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.420,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.420,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.580] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.580,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.580,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.8891e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.420,Zero),AlgebraicProduct(0.580,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0391175
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.489/VSlowLeft + 0.778/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.420,VSlowLeft),AlgebraicProduct(0.580,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: -0.000000, rot-vel: 2.241267}
[ DORIS] [2018-03-14 16:29:32]: {Distance: 1613.540405, DeltaTheta: 0.482806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.614
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.213/PNear + 0.787/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.213] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.213,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.787] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.787,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.24444e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.213,Zero),AlgebraicProduct(0.787,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0415882
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.520/VSlowLeft + 0.890/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.213,VSlowLeft),AlgebraicProduct(0.787,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:32]: {lin-vel: -0.000000, rot-vel: 2.382827}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1614.872803, DeltaTheta: 0.410228}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.615
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.384/PNear + 0.616/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.384] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.616] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.85052e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,Zero),AlgebraicProduct(0.616,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0396209
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.495/VSlowLeft + 0.801/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,VSlowLeft),AlgebraicProduct(0.616,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: -0.000000, rot-vel: 2.270111}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1614.872803, DeltaTheta: 0.147240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.615
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.023/Zero + 0.977/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.977] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.977,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.977,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.023] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.023,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.023,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.39688
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.310/Backwards + 0.000/MediumBackwards + 0.930/Zero + 0.070/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.977,Zero),AlgebraicProduct(0.023,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0238094
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.298/VSlowLeft + 0.082/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.977,VSlowLeft),AlgebraicProduct(0.023,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 1.396879, rot-vel: 1.364179}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1617.298828, DeltaTheta: -0.139668}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.617
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.875/NNear + 0.125/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.875] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.875,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.875,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.125] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.125,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.125,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.51344
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.208/Backwards + 0.000/MediumBackwards + 0.624/Zero + 0.376/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.875,Zero),AlgebraicProduct(0.125,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0191893
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.624/SlowRight + 0.872/VSlowRight + 0.128/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.875,VSlowRight),AlgebraicProduct(0.125,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 7.513442, rot-vel: -1.099466}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1619.298828, DeltaTheta: -0.051887}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.619
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1619.011841, DeltaTheta: -0.103107}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.619
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.384/NNear + 0.616/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.384] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.616] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 36.9887
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.151/MediumForward + 0.849/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,Zero),AlgebraicProduct(0.616,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00823089
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.458/SlowRight + 0.374/VSlowRight + 0.626/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,VSlowRight),AlgebraicProduct(0.616,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 36.988726, rot-vel: -0.471595}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1618.969116, DeltaTheta: -0.053507}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.619
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1613.870117, DeltaTheta: -0.053676}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.614
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1612.072266, DeltaTheta: -0.145872}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.612
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.958/NNear + 0.042/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.958] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.958,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.958,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.042] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.042,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.042,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.50218
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.292/Backwards + 0.000/MediumBackwards + 0.875/Zero + 0.125/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.958,Zero),AlgebraicProduct(0.042,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0208643
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.649/SlowRight + 0.948/VSlowRight + 0.052/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.958,VSlowRight),AlgebraicProduct(0.042,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 2.502181, rot-vel: -1.195434}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1604.434937, DeltaTheta: -0.047827}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.604
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:33]: {Distance: 1594.550171, DeltaTheta: 0.135574}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.595
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.180/Zero + 0.820/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.820] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.180] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 10.8186
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.153/Backwards + 0.000/MediumBackwards + 0.459/Zero + 0.541/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.820,Zero),AlgebraicProduct(0.180,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0170267
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.075/SlowRight + 0.000/VSlowRight + 0.226/Zero + 0.213/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.820,VSlowLeft),AlgebraicProduct(0.180,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:33]: {lin-vel: 10.818558, rot-vel: 0.975556}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1595.060059, DeltaTheta: 0.285127}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.595
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.679/PNear + 0.321/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.679] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.321] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.19173e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.679,Zero),AlgebraicProduct(0.321,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0345057
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.431/VSlowLeft + 0.568/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.679,VSlowLeft),AlgebraicProduct(0.321,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: -0.000000, rot-vel: 1.977030}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1592.060059, DeltaTheta: 0.373409}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.592
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.471/PNear + 0.529/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.471] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.471,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.471,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.529] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.529,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.529,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.5476e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.471,Zero),AlgebraicProduct(0.529,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0383755
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.480/VSlowLeft + 0.744/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.471,VSlowLeft),AlgebraicProduct(0.529,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: -0.000000, rot-vel: 2.198756}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1592.043091, DeltaTheta: 0.206226}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.592
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.865/PNear + 0.135/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.865] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.865,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.865,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.135] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.135,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.135,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.74698e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.865,Zero),AlgebraicProduct(0.135,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0296487
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.371/VSlowLeft + 0.348/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.865,VSlowLeft),AlgebraicProduct(0.135,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: -0.000000, rot-vel: 1.698743}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1588.719482, DeltaTheta: 0.233220}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.589
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.801/PNear + 0.199/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.801] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.801,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.199] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.199,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.44646e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.801,Zero),AlgebraicProduct(0.199,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0314891
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.394/VSlowLeft + 0.431/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.801,VSlowLeft),AlgebraicProduct(0.199,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: -0.000000, rot-vel: 1.804195}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1588.719482, DeltaTheta: 0.057895}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.589
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1589.892700, DeltaTheta: 0.086017}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.590
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.845/Zero + 0.155/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.155] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.155,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.155,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.845] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.845,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.845,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 50.7354
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.463/Forward + 0.537/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.155,Zero),AlgebraicProduct(0.845,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00186384
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.305/SlowRight + 0.000/VSlowRight + 0.915/Zero + 0.023/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.155,VSlowLeft),AlgebraicProduct(0.845,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: 50.735433, rot-vel: 0.106790}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1590.772705, DeltaTheta: -0.010504}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.591
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1587.610474, DeltaTheta: -0.186025}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.588
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.087/NFar + 0.913/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.087] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.913] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.18942e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.087,Zero),AlgebraicProduct(0.913,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0227733
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.678/SlowRight + 0.965/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.087,SlowRight),AlgebraicProduct(0.913,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: -0.000000, rot-vel: -1.304812}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1582.655518, DeltaTheta: -0.107418}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.583
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.442/NNear + 0.558/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.442] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.442,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.442,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.558] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.558,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.558,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.5182
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.324/MediumForward + 0.676/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.442,Zero),AlgebraicProduct(0.558,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00955503
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.478/SlowRight + 0.434/VSlowRight + 0.566/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.442,VSlowRight),AlgebraicProduct(0.558,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: 33.518184, rot-vel: -0.547463}
[ DORIS] [2018-03-14 16:29:34]: {Distance: 1571.729370, DeltaTheta: 0.032886}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.572
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:34]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1568.781006, DeltaTheta: 0.188572}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.569
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.907/PNear + 0.093/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.907] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.907,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.907,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.093] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.093,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.093,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.86245e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.907,Zero),AlgebraicProduct(0.093,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.02833
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.354/VSlowLeft + 0.288/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.907,VSlowLeft),AlgebraicProduct(0.093,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: -0.000000, rot-vel: 1.623192}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1568.411377, DeltaTheta: 0.308454}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.568
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.624/PNear + 0.376/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.624] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.376] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.29598e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,Zero),AlgebraicProduct(0.376,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0356669
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.446/VSlowLeft + 0.621/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,VSlowLeft),AlgebraicProduct(0.376,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: -0.000000, rot-vel: 2.043564}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1565.411499, DeltaTheta: 0.309045}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.565
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.622/PNear + 0.378/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.622] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.622,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.622,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.378] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.378,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.378,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.48305e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.622,Zero),AlgebraicProduct(0.378,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0356949
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.446/VSlowLeft + 0.622/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.622,VSlowLeft),AlgebraicProduct(0.378,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: -0.000000, rot-vel: 2.045169}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1566.104980, DeltaTheta: 0.034561}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.566
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1567.651733, DeltaTheta: -0.098596}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.568
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.324/NNear + 0.676/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.324] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.676] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.6191
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.969/Forward + 0.031/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,Zero),AlgebraicProduct(0.676,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00685749
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.437/SlowRight + 0.312/VSlowRight + 0.688/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,VSlowRight),AlgebraicProduct(0.676,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 40.619056, rot-vel: -0.392905}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1563.735718, DeltaTheta: -0.087806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.564
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.179/NNear + 0.821/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.179] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.179,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.179,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.821] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.821,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.821,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 49.2972
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.535/Forward + 0.465/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.179,Zero),AlgebraicProduct(0.821,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00366357
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.389/SlowRight + 0.167/VSlowRight + 0.833/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.179,VSlowRight),AlgebraicProduct(0.821,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 49.297229, rot-vel: -0.209907}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1558.487305, DeltaTheta: 0.079556}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.558
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.932/Zero + 0.068/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.068] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.932] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 55.9267
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.204/Forward + 0.796/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.068,Zero),AlgebraicProduct(0.932,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000772097
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.322/SlowRight + 0.000/VSlowRight + 0.965/Zero + 0.010/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.068,VSlowLeft),AlgebraicProduct(0.932,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 55.926668, rot-vel: 0.044238}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1551.942139, DeltaTheta: 0.081373}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.552
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.908/Zero + 0.092/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.092] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.092,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.092,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.908] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.908,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.908,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.4675
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.277/Forward + 0.723/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.092,Zero),AlgebraicProduct(0.908,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00106618
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.317/SlowRight + 0.000/VSlowRight + 0.952/Zero + 0.013/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.092,VSlowLeft),AlgebraicProduct(0.908,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 54.467472, rot-vel: 0.061088}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1549.414062, DeltaTheta: -0.038401}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.549
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:35]: {Distance: 1542.342896, DeltaTheta: -0.038577}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.542
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:35]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1539.554810, DeltaTheta: -0.227159}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.540
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.184/NFar + 0.816/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.184] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.184,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.184,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.816] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.816,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.816,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.05025e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.184,Zero),AlgebraicProduct(0.816,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0239178
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.696/SlowRight + 0.913/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.184,SlowRight),AlgebraicProduct(0.816,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: -0.000000, rot-vel: -1.370387}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1537.645386, DeltaTheta: -0.259420}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.538
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.261/NFar + 0.739/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.261] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.261,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.261,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.739] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.739,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.739,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.1213e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.261,Zero),AlgebraicProduct(0.739,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0247372
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.708/SlowRight + 0.876/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.261,SlowRight),AlgebraicProduct(0.739,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: -0.000000, rot-vel: -1.417337}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1534.989502, DeltaTheta: -0.219354}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.166/NFar + 0.834/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.166] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.166,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.166,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.834] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.834,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.834,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.11995e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.166,Zero),AlgebraicProduct(0.834,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0237087
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.693/SlowRight + 0.922/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.166,SlowRight),AlgebraicProduct(0.834,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: -0.000000, rot-vel: -1.358406}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1533.989502, DeltaTheta: 0.131267}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.534
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.238/Zero + 0.762/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.762] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.238] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 14.2941
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.095/Backwards + 0.000/MediumBackwards + 0.285/Zero + 0.715/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.762,Zero),AlgebraicProduct(0.238,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0149754
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.106/SlowRight + 0.000/VSlowRight + 0.319/Zero + 0.187/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.762,VSlowLeft),AlgebraicProduct(0.238,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 14.294148, rot-vel: 0.858030}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1535.271606, DeltaTheta: 0.140578}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.113/Zero + 0.887/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.887] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.887,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.887,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.113] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.113,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.113,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.77847
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.220/Backwards + 0.000/MediumBackwards + 0.661/Zero + 0.339/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.887,Zero),AlgebraicProduct(0.113,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0196938
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.035/SlowRight + 0.000/VSlowRight + 0.105/Zero + 0.246/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.887,VSlowLeft),AlgebraicProduct(0.113,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 6.778470, rot-vel: 1.128372}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1536.271606, DeltaTheta: 0.140487}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.536
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.114/Zero + 0.886/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.886] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.886,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.886,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.114] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.114,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.114,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.85237
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.219/Backwards + 0.000/MediumBackwards + 0.657/Zero + 0.343/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.886,Zero),AlgebraicProduct(0.114,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.019642
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.036/SlowRight + 0.000/VSlowRight + 0.107/Zero + 0.246/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.886,VSlowLeft),AlgebraicProduct(0.114,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 6.852366, rot-vel: 1.125405}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1537.156006, DeltaTheta: 0.065524}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.537
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1536.882080, DeltaTheta: 0.072445}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.537
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1534.645996, DeltaTheta: -0.015176}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:36]: {Distance: 1532.507446, DeltaTheta: -0.018902}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.533
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:36]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1526.424683, DeltaTheta: -0.018977}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.526
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1520.758057, DeltaTheta: -0.030686}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.521
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1516.696533, DeltaTheta: -0.121495}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.517
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.631/NNear + 0.369/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.631] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.369] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.1757
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.891/MediumForward + 0.109/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.631,Zero),AlgebraicProduct(0.369,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0138802
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.544/SlowRight + 0.631/VSlowRight + 0.369/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.631,VSlowRight),AlgebraicProduct(0.369,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 22.175701, rot-vel: -0.795278}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1510.613770, DeltaTheta: -0.121985}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.511
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.638/NNear + 0.362/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.638] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.638,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.638,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.362] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.362,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.362,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.7813
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.911/MediumForward + 0.089/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.638,Zero),AlgebraicProduct(0.362,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0140288
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.546/SlowRight + 0.638/VSlowRight + 0.362/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.638,VSlowRight),AlgebraicProduct(0.362,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 21.781278, rot-vel: -0.803789}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1508.865234, DeltaTheta: -0.125405}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.509
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.684/NNear + 0.316/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.684] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.684,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.684,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.316] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.316,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.316,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 19.0231
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.016/Backwards + 0.000/MediumBackwards + 0.049/Zero + 0.951/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.684,Zero),AlgebraicProduct(0.316,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.015061
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.562/SlowRight + 0.685/VSlowRight + 0.315/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.684,VSlowRight),AlgebraicProduct(0.316,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 19.023068, rot-vel: -0.862931}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1508.311646, DeltaTheta: 0.014902}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.508
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1508.311646, DeltaTheta: 0.014902}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.508
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1507.048218, DeltaTheta: 0.078300}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.507
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.949/Zero + 0.051/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.051] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.949] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.9358
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.153/Forward + 0.847/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.051,Zero),AlgebraicProduct(0.949,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000574266
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.325/SlowRight + 0.000/VSlowRight + 0.974/Zero + 0.007/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.051,VSlowLeft),AlgebraicProduct(0.949,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: 56.935763, rot-vel: 0.032903}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1503.156372, DeltaTheta: 0.159750}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.503
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.975/PNear + 0.025/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.975] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.975,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.025] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.025,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.26538e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.975,Zero),AlgebraicProduct(0.025,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.025961
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.325/VSlowLeft + 0.180/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.975,VSlowLeft),AlgebraicProduct(0.025,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: -0.000000, rot-vel: 1.487453}
[ DORIS] [2018-03-14 16:29:37]: {Distance: 1496.085327, DeltaTheta: 0.248375}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.496
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.766/PNear + 0.234/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.766] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.234] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.13033e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,Zero),AlgebraicProduct(0.234,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0324368
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.405/VSlowLeft + 0.474/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,VSlowLeft),AlgebraicProduct(0.234,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:37]: {lin-vel: -0.000000, rot-vel: 1.858494}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1486.951904, DeltaTheta: 0.373524}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.487
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.470/PNear + 0.530/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.470] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.530] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.59722e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,Zero),AlgebraicProduct(0.530,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0383797
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.480/VSlowLeft + 0.745/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,VSlowLeft),AlgebraicProduct(0.530,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: 2.198995}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1479.560425, DeltaTheta: 0.427992}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.342/PNear + 0.658/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.342] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.658] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.30342e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.342,Zero),AlgebraicProduct(0.658,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.040158
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.502/VSlowLeft + 0.825/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.342,VSlowLeft),AlgebraicProduct(0.658,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: 2.300882}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1478.957764, DeltaTheta: 0.404938}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.479
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.396/PNear + 0.604/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.396] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.604] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.46297e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,Zero),AlgebraicProduct(0.604,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0394533
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.493/VSlowLeft + 0.793/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,VSlowLeft),AlgebraicProduct(0.604,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: 2.260506}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1479.888428, DeltaTheta: 0.248098}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.766/PNear + 0.234/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.766] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.234] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.98437e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,Zero),AlgebraicProduct(0.234,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.03242
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.405/VSlowLeft + 0.474/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,VSlowLeft),AlgebraicProduct(0.234,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: 1.857530}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1481.888428, DeltaTheta: 0.072556}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.482
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1480.974121, DeltaTheta: -0.072389}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.481
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1479.974121, DeltaTheta: -0.160130}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.026/NFar + 0.974/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.026] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.974] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.51807e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,Zero),AlgebraicProduct(0.974,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.022006
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.667/SlowRight + 1.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,SlowRight),AlgebraicProduct(0.974,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: -1.260849}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1478.874390, DeltaTheta: -0.163010}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.479
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.033/NFar + 0.967/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.033] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.033,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.033,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.967] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.967,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.967,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.32984e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.033,Zero),AlgebraicProduct(0.967,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0220927
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.668/SlowRight + 0.996/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.033,SlowRight),AlgebraicProduct(0.967,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: -1.265821}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1476.599121, DeltaTheta: -0.201207}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.477
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.123/NFar + 0.877/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.123] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.123,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.123,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.877] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.877,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.877,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.36818e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.123,Zero),AlgebraicProduct(0.877,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0232075
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.685/SlowRight + 0.945/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.123,SlowRight),AlgebraicProduct(0.877,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: -1.329690}
[ DORIS] [2018-03-14 16:29:38]: {Distance: 1474.599121, DeltaTheta: -0.289202}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.475
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.331/NFar + 0.669/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.331] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.669] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.64888e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.331,Zero),AlgebraicProduct(0.669,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0254253
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.719/SlowRight + 0.844/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.331,SlowRight),AlgebraicProduct(0.669,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:38]: {lin-vel: -0.000000, rot-vel: -1.456765}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1474.822266, DeltaTheta: -0.144828}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.475
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.944/NNear + 0.056/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.944] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.056] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.3459
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.278/Backwards + 0.000/MediumBackwards + 0.833/Zero + 0.167/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.944,Zero),AlgebraicProduct(0.056,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0205884
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.645/SlowRight + 0.936/VSlowRight + 0.064/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.944,VSlowRight),AlgebraicProduct(0.056,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 3.345899, rot-vel: -1.179630}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1475.822266, DeltaTheta: 0.118169}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.476
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.414/Zero + 0.586/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.586] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.586,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.586,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.414] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.414,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.414,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 24.8573
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.757/MediumForward + 0.243/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.586,Zero),AlgebraicProduct(0.414,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00984557
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.184/SlowRight + 0.000/VSlowRight + 0.552/Zero + 0.123/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.586,VSlowLeft),AlgebraicProduct(0.414,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 24.857345, rot-vel: 0.564110}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1479.765381, DeltaTheta: 0.046934}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.480
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1479.185181, DeltaTheta: 0.017446}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.479
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1477.185181, DeltaTheta: -0.070253}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.477
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1468.060791, DeltaTheta: 0.125997}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.468
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.308/Zero + 0.692/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.692] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.692,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.692,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.308] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.308,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.308,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 18.5461
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.024/Backwards + 0.000/MediumBackwards + 0.073/Zero + 0.927/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.692,Zero),AlgebraicProduct(0.308,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0127292
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.140/SlowRight + 0.000/VSlowRight + 0.421/Zero + 0.159/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.692,VSlowLeft),AlgebraicProduct(0.308,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 18.546080, rot-vel: 0.729329}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1460.028320, DeltaTheta: 0.124737}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.460
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.325/Zero + 0.675/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.675] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.675,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.675,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.325] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.325,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.325,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 19.562
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.007/Backwards + 0.000/MediumBackwards + 0.022/Zero + 0.978/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.675,Zero),AlgebraicProduct(0.325,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0122309
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.148/SlowRight + 0.000/VSlowRight + 0.444/Zero + 0.153/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.675,VSlowLeft),AlgebraicProduct(0.325,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 19.562032, rot-vel: 0.700780}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1449.750854, DeltaTheta: 0.146904}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.450
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.028/Zero + 0.972/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.972] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.972,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.972,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.028] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.028,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.028,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.66861
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.306/Backwards + 0.000/MediumBackwards + 0.917/Zero + 0.083/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.972,Zero),AlgebraicProduct(0.028,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0235841
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.295/VSlowLeft + 0.072/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.972,VSlowLeft),AlgebraicProduct(0.028,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 1.668608, rot-vel: 1.351270}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1447.155151, DeltaTheta: 0.155474}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.447
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.985/PNear + 0.015/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.985] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.985,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.985,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.015] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.015,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.015,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.9738e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.985,Zero),AlgebraicProduct(0.015,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0255849
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.320/VSlowLeft + 0.163/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.985,VSlowLeft),AlgebraicProduct(0.015,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: 0.000000, rot-vel: 1.465907}
[ DORIS] [2018-03-14 16:29:39]: {Distance: 1445.754150, DeltaTheta: 0.321605}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.446
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.593/PNear + 0.407/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.593] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.593,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.593,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.407] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.407,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.407,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.37835e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.593,Zero),AlgebraicProduct(0.407,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0362746
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.453/VSlowLeft + 0.649/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.593,VSlowLeft),AlgebraicProduct(0.407,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:39]: {lin-vel: -0.000000, rot-vel: 2.078380}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1445.376221, DeltaTheta: 0.194805}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.445
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.892/PNear + 0.108/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.892] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.892,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.892,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.108] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.108,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.108,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.91514e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.892,Zero),AlgebraicProduct(0.108,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0288066
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.360/VSlowLeft + 0.309/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.892,VSlowLeft),AlgebraicProduct(0.108,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: -0.000000, rot-vel: 1.650494}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1448.424927, DeltaTheta: 0.017057}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.448
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1448.424927, DeltaTheta: 0.017057}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.448
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1448.899292, DeltaTheta: -0.077877}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.449
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.046/NNear + 0.954/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.046] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.046,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.046,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.954] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.954,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.954,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 57.2757
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.136/Forward + 0.864/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.046,Zero),AlgebraicProduct(0.954,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.000896852
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.347/SlowRight + 0.041/VSlowRight + 0.959/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.046,VSlowRight),AlgebraicProduct(0.954,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: 57.275694, rot-vel: -0.051386}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1447.115112, DeltaTheta: -0.196365}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.447
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.112/NFar + 0.888/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.112] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.112,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.112,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.888] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.888,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.888,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.22092e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.112,Zero),AlgebraicProduct(0.888,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0230704
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.683/SlowRight + 0.951/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.112,SlowRight),AlgebraicProduct(0.888,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: -0.000000, rot-vel: -1.321836}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1441.032471, DeltaTheta: -0.285042}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.441
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.321/NFar + 0.679/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.321] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.679] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.93792e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.321,Zero),AlgebraicProduct(0.679,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0253333
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.717/SlowRight + 0.848/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.321,SlowRight),AlgebraicProduct(0.679,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: -0.000000, rot-vel: -1.451491}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1437.929443, DeltaTheta: -0.397820}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.438
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.587/NFar + 0.413/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.587] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.413] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.08066e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.587,Zero),AlgebraicProduct(0.413,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0273593
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.748/SlowRight + 0.756/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.587,SlowRight),AlgebraicProduct(0.413,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: -0.000000, rot-vel: -1.567574}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1438.115601, DeltaTheta: -0.431869}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.438
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.667/NFar + 0.333/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.667] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.333] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.39499e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,Zero),AlgebraicProduct(0.333,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0277908
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.754/SlowRight + 0.737/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,SlowRight),AlgebraicProduct(0.333,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: -0.000000, rot-vel: -1.592297}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1438.115601, DeltaTheta: 0.006444}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.438
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:40]: {Distance: 1441.752197, DeltaTheta: 0.101956}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.442
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.631/Zero + 0.369/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.369] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.631] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 37.9152
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.104/MediumForward + 0.896/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.369,Zero),AlgebraicProduct(0.631,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00519381
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.255/SlowRight + 0.000/VSlowRight + 0.764/Zero + 0.065/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.369,VSlowLeft),AlgebraicProduct(0.631,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:40]: {lin-vel: 37.915184, rot-vel: 0.297583}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1443.166382, DeltaTheta: 0.189476}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.443
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.904/PNear + 0.096/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.904] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.096] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.90419e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.904,Zero),AlgebraicProduct(0.096,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0283999
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.355/VSlowLeft + 0.291/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.904,VSlowLeft),AlgebraicProduct(0.096,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: -0.000000, rot-vel: 1.627196}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1440.108643, DeltaTheta: 0.226755}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.440
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.817/PNear + 0.183/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.817] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.817,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.817,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.183] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.183,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.183,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.54094e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.817,Zero),AlgebraicProduct(0.183,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0310667
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.388/VSlowLeft + 0.412/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.817,VSlowLeft),AlgebraicProduct(0.183,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 0.000000, rot-vel: 1.779990}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1437.511841, DeltaTheta: 0.211535}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.438
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.852/PNear + 0.148/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.852] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.148] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.49089e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.852,Zero),AlgebraicProduct(0.148,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0300269
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.375/VSlowLeft + 0.365/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.852,VSlowLeft),AlgebraicProduct(0.148,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: -0.000000, rot-vel: 1.720413}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1435.275757, DeltaTheta: -0.051328}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.435
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1435.728638, DeltaTheta: -0.110690}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.436
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.486/NNear + 0.514/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.486] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.514] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 30.8829
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.456/MediumForward + 0.544/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.486,Zero),AlgebraicProduct(0.514,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0105638
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.493/SlowRight + 0.480/VSlowRight + 0.520/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.486,VSlowRight),AlgebraicProduct(0.514,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 30.882921, rot-vel: -0.605263}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1435.893799, DeltaTheta: -0.102927}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.436
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.382/NNear + 0.618/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.382] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.382,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.382,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.618] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.618,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.618,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 37.134
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.143/MediumForward + 0.857/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.382,Zero),AlgebraicProduct(0.618,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00817565
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.457/SlowRight + 0.372/VSlowRight + 0.628/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.382,VSlowRight),AlgebraicProduct(0.618,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 37.134026, rot-vel: -0.468430}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1435.893799, DeltaTheta: -0.190589}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.436
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.098/NFar + 0.902/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.098] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.902] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.21586e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,Zero),AlgebraicProduct(0.902,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0229051
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.680/SlowRight + 0.959/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.098,SlowRight),AlgebraicProduct(0.902,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: -0.000000, rot-vel: -1.312368}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1432.761963, DeltaTheta: -0.028545}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.433
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1425.964966, DeltaTheta: 0.044049}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.426
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:41]: {Distance: 1421.025635, DeltaTheta: 0.178979}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.421
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.929/PNear + 0.071/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.929] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.071] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.77263e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.929,Zero),AlgebraicProduct(0.071,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0275725
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.345/VSlowLeft + 0.253/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.929,VSlowLeft),AlgebraicProduct(0.071,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:41]: {lin-vel: -0.000000, rot-vel: 1.579787}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1419.667480, DeltaTheta: 0.142447}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.420
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.088/Zero + 0.912/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.912] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.088] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.26891
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.246/Backwards + 0.000/MediumBackwards + 0.737/Zero + 0.263/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,Zero),AlgebraicProduct(0.088,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0207783
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.019/SlowRight + 0.000/VSlowRight + 0.056/Zero + 0.260/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,VSlowLeft),AlgebraicProduct(0.088,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 5.268915, rot-vel: 1.190510}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1413.254639, DeltaTheta: 0.226143}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.413
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.818/PNear + 0.182/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.818] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.818,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.818,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.182] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.182,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.182,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.51456e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.818,Zero),AlgebraicProduct(0.182,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0310261
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.388/VSlowLeft + 0.410/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.818,VSlowLeft),AlgebraicProduct(0.182,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: -0.000000, rot-vel: 1.777667}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1409.605347, DeltaTheta: 0.126205}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.410
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.306/Zero + 0.694/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.694] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.694,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.694,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.306] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.306,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.306,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 18.3781
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.027/Backwards + 0.000/MediumBackwards + 0.081/Zero + 0.919/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.694,Zero),AlgebraicProduct(0.306,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0128129
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.139/SlowRight + 0.000/VSlowRight + 0.418/Zero + 0.160/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.694,VSlowLeft),AlgebraicProduct(0.306,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 18.378113, rot-vel: 0.734127}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1409.183716, DeltaTheta: -0.014696}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.409
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1409.183716, DeltaTheta: -0.102359}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.409
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.374/NNear + 0.626/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.374] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.374,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.374,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.626] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.626,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.626,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 37.5911
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.120/MediumForward + 0.880/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.374,Zero),AlgebraicProduct(0.626,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.008002
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.455/SlowRight + 0.364/VSlowRight + 0.636/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.374,VSlowRight),AlgebraicProduct(0.626,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 37.591089, rot-vel: -0.458481}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1409.144287, DeltaTheta: -0.024089}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.409
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1405.021118, DeltaTheta: -0.024160}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.405
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1402.612305, DeltaTheta: -0.149963}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.403
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.002/NFar + 0.998/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.002] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.002,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.002,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.998] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.998,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.998,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.02557e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.002,Zero),AlgebraicProduct(0.998,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0216971
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.986/VSlowRight + 0.014/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.002,SlowRight),AlgebraicProduct(0.998,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: -0.000000, rot-vel: -1.243150}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1398.518188, DeltaTheta: -0.191239}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.399
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.100/NFar + 0.900/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.100] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.100,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.100,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.900] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.900,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.900,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.01608e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.100,Zero),AlgebraicProduct(0.900,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0229238
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.681/SlowRight + 0.958/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.100,SlowRight),AlgebraicProduct(0.900,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: -0.000000, rot-vel: -1.313438}
[ DORIS] [2018-03-14 16:29:42]: {Distance: 1392.435547, DeltaTheta: -0.279928}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.392
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.309/NFar + 0.691/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.309] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.309,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.691] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.691,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.07877e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.309,Zero),AlgebraicProduct(0.691,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252183
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.715/SlowRight + 0.854/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.309,SlowRight),AlgebraicProduct(0.691,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:42]: {lin-vel: -0.000000, rot-vel: -1.444904}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1393.656494, DeltaTheta: -0.147691}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.394
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.983/NNear + 0.017/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.983] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.017] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.03272
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.316/Backwards + 0.000/MediumBackwards + 0.948/Zero + 0.052/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.983,Zero),AlgebraicProduct(0.017,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0213384
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.657/SlowRight + 0.970/VSlowRight + 0.030/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.983,VSlowRight),AlgebraicProduct(0.017,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 1.032719, rot-vel: -1.222598}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1395.495117, DeltaTheta: -0.105888}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.395
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.422/NNear + 0.578/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.422] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.578] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 34.7503
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.262/MediumForward + 0.738/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.422,Zero),AlgebraicProduct(0.578,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00908411
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.471/SlowRight + 0.413/VSlowRight + 0.587/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.422,VSlowRight),AlgebraicProduct(0.578,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 34.750258, rot-vel: -0.520481}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1397.731201, DeltaTheta: -0.105718}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.398
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.419/NNear + 0.581/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.419] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.419,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.419,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.581] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.581,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.581,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 34.8866
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.256/MediumForward + 0.744/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.419,Zero),AlgebraicProduct(0.581,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00903202
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.470/SlowRight + 0.411/VSlowRight + 0.589/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.419,VSlowRight),AlgebraicProduct(0.581,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 34.886649, rot-vel: -0.517497}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1398.540649, DeltaTheta: 0.138732}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.399
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.137/Zero + 0.863/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.863] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.863,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.863,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.137] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.137,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.137,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 8.26905
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.196/Backwards + 0.000/MediumBackwards + 0.587/Zero + 0.413/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.863,Zero),AlgebraicProduct(0.137,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0186715
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.050/SlowRight + 0.000/VSlowRight + 0.151/Zero + 0.233/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.863,VSlowLeft),AlgebraicProduct(0.137,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 8.269050, rot-vel: 1.069798}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1395.540649, DeltaTheta: 0.314544}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.396
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.609/PNear + 0.391/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.609] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.609,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.391] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.391,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.62139e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,Zero),AlgebraicProduct(0.391,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0359523
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.449/VSlowLeft + 0.634/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.609,VSlowLeft),AlgebraicProduct(0.391,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: -0.000000, rot-vel: 2.059917}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1392.656494, DeltaTheta: 0.276266}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.393
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.700/PNear + 0.300/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.700] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.700,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.700,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.300] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.300,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.300,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.63957e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.700,Zero),AlgebraicProduct(0.300,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0340349
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.425/VSlowLeft + 0.547/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.700,VSlowLeft),AlgebraicProduct(0.300,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: -0.000000, rot-vel: 1.950053}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1391.569702, DeltaTheta: 0.105374}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.392
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.585/Zero + 0.415/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.415] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.415,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.415,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.585] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.585,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.585,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 35.1642
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.242/MediumForward + 0.758/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.415,Zero),AlgebraicProduct(0.585,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00605126
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.242/SlowRight + 0.000/VSlowRight + 0.725/Zero + 0.076/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.415,VSlowLeft),AlgebraicProduct(0.585,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 35.164164, rot-vel: 0.346712}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1390.371460, DeltaTheta: -0.052525}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.390
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1390.371460, DeltaTheta: -0.140188}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.390
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.882/NNear + 0.118/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.882] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.118] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.0937
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.215/Backwards + 0.000/MediumBackwards + 0.645/Zero + 0.355/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,Zero),AlgebraicProduct(0.118,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0193329
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.626/SlowRight + 0.879/VSlowRight + 0.121/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,VSlowRight),AlgebraicProduct(0.118,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 7.093699, rot-vel: -1.107691}
[ DORIS] [2018-03-14 16:29:43]: {Distance: 1389.202393, DeltaTheta: -0.138091}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.389
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.854/NNear + 0.146/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.854] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.146] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 8.78643
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.187/Backwards + 0.000/MediumBackwards + 0.561/Zero + 0.439/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.854,Zero),AlgebraicProduct(0.146,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0187505
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.617/SlowRight + 0.852/VSlowRight + 0.148/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.854,VSlowRight),AlgebraicProduct(0.146,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:43]: {lin-vel: 8.786430, rot-vel: -1.074323}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1385.079346, DeltaTheta: -0.050709}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.385
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1382.976074, DeltaTheta: -0.079234}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.383
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.064/NNear + 0.936/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.1854
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.191/Forward + 0.809/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,Zero),AlgebraicProduct(0.936,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00126307
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.352/SlowRight + 0.057/VSlowRight + 0.943/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,VSlowRight),AlgebraicProduct(0.936,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 56.185420, rot-vel: -0.072369}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1381.782959, DeltaTheta: -0.084210}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.382
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.131/NNear + 0.869/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.131] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.131,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.131,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.869] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.869,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.869,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.1877
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.391/Forward + 0.609/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.131,Zero),AlgebraicProduct(0.869,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00263906
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.373/SlowRight + 0.120/VSlowRight + 0.880/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.131,VSlowRight),AlgebraicProduct(0.869,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 52.187684, rot-vel: -0.151207}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1377.839722, DeltaTheta: -0.057778}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.378
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1373.898926, DeltaTheta: 0.078329}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.374
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.948/Zero + 0.052/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.052] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.948] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.9129
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.154/Forward + 0.846/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.052,Zero),AlgebraicProduct(0.948,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000578701
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.325/SlowRight + 0.000/VSlowRight + 0.974/Zero + 0.007/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.052,VSlowLeft),AlgebraicProduct(0.948,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 56.912890, rot-vel: 0.033157}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1368.799927, DeltaTheta: 0.078620}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.369
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.944/Zero + 0.056/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.056] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.056,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.944] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.944,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.6785
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.166/Forward + 0.834/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.056,Zero),AlgebraicProduct(0.944,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000624277
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.324/SlowRight + 0.000/VSlowRight + 0.972/Zero + 0.008/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.056,VSlowLeft),AlgebraicProduct(0.944,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 56.678515, rot-vel: 0.035768}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1360.633545, DeltaTheta: 0.122908}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.361
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.350/Zero + 0.650/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.650] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.650,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.650,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.350] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.350,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.350,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.0367
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.948/MediumForward + 0.052/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.650,Zero),AlgebraicProduct(0.350,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.011532
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.159/SlowRight + 0.000/VSlowRight + 0.476/Zero + 0.144/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.650,VSlowLeft),AlgebraicProduct(0.350,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 21.036676, rot-vel: 0.660734}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1355.468262, DeltaTheta: 0.219346}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.355
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.834/PNear + 0.166/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.834] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.834,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.834,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.166] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.166,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.166,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.37092e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.834,Zero),AlgebraicProduct(0.166,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0305686
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.382/VSlowLeft + 0.389/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.834,VSlowLeft),AlgebraicProduct(0.166,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: -0.000000, rot-vel: 1.751452}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1350.369263, DeltaTheta: 0.220174}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.350
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.832/PNear + 0.168/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.832] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.832,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.168] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.168,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.23036e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.832,Zero),AlgebraicProduct(0.168,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.030625
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.383/VSlowLeft + 0.392/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.832,VSlowLeft),AlgebraicProduct(0.168,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: -0.000000, rot-vel: 1.754685}
[ DORIS] [2018-03-14 16:29:44]: {Distance: 1349.394409, DeltaTheta: 0.109883}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.349
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.525/Zero + 0.475/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.475] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.475,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.475,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.525] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.525,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.525,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 31.5329
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.423/MediumForward + 0.577/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.475,Zero),AlgebraicProduct(0.525,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00727621
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.223/SlowRight + 0.000/VSlowRight + 0.669/Zero + 0.091/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.475,VSlowLeft),AlgebraicProduct(0.525,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:44]: {lin-vel: 31.532872, rot-vel: 0.416896}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1350.394409, DeltaTheta: -0.065458}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.350
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1350.509155, DeltaTheta: -0.301550}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.351
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.360/NFar + 0.640/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.360] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.640] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.3151e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.360,Zero),AlgebraicProduct(0.640,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0256906
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.723/SlowRight + 0.832/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.360,SlowRight),AlgebraicProduct(0.640,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: -0.000000, rot-vel: -1.471965}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1349.486816, DeltaTheta: -0.205067}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.349
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.132/NFar + 0.868/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.132] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.132,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.132,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.868] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.868,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.868,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.51548e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.132,Zero),AlgebraicProduct(0.868,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0233158
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.687/SlowRight + 0.940/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.132,SlowRight),AlgebraicProduct(0.868,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: -0.000000, rot-vel: -1.335894}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1344.387817, DeltaTheta: -0.118016}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.344
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.584/NNear + 0.416/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.584] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.584,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.584,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.416] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.416,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.416,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 24.9808
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.751/MediumForward + 0.249/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.584,Zero),AlgebraicProduct(0.416,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0128182
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.528/SlowRight + 0.583/VSlowRight + 0.417/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.584,VSlowRight),AlgebraicProduct(0.416,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 24.980832, rot-vel: -0.734430}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1342.282593, DeltaTheta: -0.149916}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.342
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.002/NFar + 0.998/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.002] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.002,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.002,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.998] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.998,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.998,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.42937e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.002,Zero),AlgebraicProduct(0.998,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0216956
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.986/VSlowRight + 0.014/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.002,SlowRight),AlgebraicProduct(0.998,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: -0.000000, rot-vel: -1.243068}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1341.997437, DeltaTheta: -0.074459}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.342
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar - 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1342.236938, DeltaTheta: 0.114656}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.342
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.461/Zero + 0.539/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.539] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.539,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.539,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.461] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.461,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.461,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 27.6878
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.616/MediumForward + 0.384/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.539,Zero),AlgebraicProduct(0.461,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00870181
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.201/SlowRight + 0.000/VSlowRight + 0.604/Zero + 0.109/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.539,VSlowLeft),AlgebraicProduct(0.461,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 27.687830, rot-vel: 0.498577}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1341.400269, DeltaTheta: 0.014910}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.341
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1340.400269, DeltaTheta: 0.014921}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.340
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:45]: {Distance: 1336.212524, DeltaTheta: 0.099526}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.336
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.664/Zero + 0.336/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.336] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.336,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.336,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.664] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.664,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.664,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 39.8712
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.006/MediumForward + 0.994/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.336,Zero),AlgebraicProduct(0.664,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00461814
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.263/SlowRight + 0.000/VSlowRight + 0.790/Zero + 0.058/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.336,VSlowLeft),AlgebraicProduct(0.664,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:45]: {lin-vel: 39.871200, rot-vel: 0.264600}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1330.512817, DeltaTheta: 0.093641}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.331
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.743/Zero + 0.257/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.257] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.257,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.257,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.743] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.743,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.743,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.6053
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.770/Forward + 0.230/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.257,Zero),AlgebraicProduct(0.743,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00333145
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.283/SlowRight + 0.000/VSlowRight + 0.849/Zero + 0.042/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.257,VSlowLeft),AlgebraicProduct(0.743,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 44.605259, rot-vel: 0.190878}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1323.232788, DeltaTheta: 0.094156}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.323
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.736/Zero + 0.264/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.264] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.264,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.264,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.736] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.736,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.736,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.1909
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.790/Forward + 0.210/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.264,Zero),AlgebraicProduct(0.736,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00343841
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.281/SlowRight + 0.000/VSlowRight + 0.844/Zero + 0.043/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.264,VSlowLeft),AlgebraicProduct(0.736,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 44.190888, rot-vel: 0.197006}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1321.191284, DeltaTheta: 0.078214}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.321
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.950/Zero + 0.050/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.050] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.950] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 57.0045
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.150/Forward + 0.850/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.050,Zero),AlgebraicProduct(0.950,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000560942
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.325/SlowRight + 0.000/VSlowRight + 0.975/Zero + 0.007/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.050,VSlowLeft),AlgebraicProduct(0.950,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 57.004548, rot-vel: 0.032140}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1317.964722, DeltaTheta: 0.063931}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.318
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1314.802490, DeltaTheta: 0.064085}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.315
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1311.364502, DeltaTheta: 0.141633}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.311
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.098/Zero + 0.902/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.902] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.902,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.098] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.098,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.92611
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.235/Backwards + 0.000/MediumBackwards + 0.704/Zero + 0.296/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.902,Zero),AlgebraicProduct(0.098,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0202999
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.026/SlowRight + 0.000/VSlowRight + 0.077/Zero + 0.254/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.902,VSlowLeft),AlgebraicProduct(0.098,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 5.926107, rot-vel: 1.163098}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1306.141846, DeltaTheta: 0.134588}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.306
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.193/Zero + 0.807/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.807] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.193] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.6145
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.140/Backwards + 0.000/MediumBackwards + 0.419/Zero + 0.581/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.807,Zero),AlgebraicProduct(0.193,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0165383
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.083/SlowRight + 0.000/VSlowRight + 0.248/Zero + 0.207/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.807,VSlowLeft),AlgebraicProduct(0.193,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 11.614455, rot-vel: 0.947576}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1300.217407, DeltaTheta: 0.145130}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.300
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.052/Zero + 0.948/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.948] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.948,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.052] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.052,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.10169
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.282/Backwards + 0.000/MediumBackwards + 0.845/Zero + 0.155/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.948,Zero),AlgebraicProduct(0.052,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0224283
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.280/VSlowLeft + 0.019/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.948,VSlowLeft),AlgebraicProduct(0.052,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 3.101688, rot-vel: 1.285047}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1298.508911, DeltaTheta: 0.154250}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.299
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.988/PNear + 0.012/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.988] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.012] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.18178e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.988,Zero),AlgebraicProduct(0.012,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.025476
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.318/VSlowLeft + 0.158/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.988,VSlowLeft),AlgebraicProduct(0.012,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: -0.000000, rot-vel: 1.459667}
[ DORIS] [2018-03-14 16:29:46]: {Distance: 1298.548950, DeltaTheta: 0.024976}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.299
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:46]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1300.158813, DeltaTheta: 0.055555}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.300
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1298.907471, DeltaTheta: -0.009848}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.299
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1296.671387, DeltaTheta: -0.009865}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.297
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1289.783691, DeltaTheta: -0.009195}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.290
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1280.728271, DeltaTheta: 0.078713}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.281
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.943/Zero + 0.057/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.057] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.057,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.057,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.943] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.943,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.943,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.6042
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.170/Forward + 0.830/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.057,Zero),AlgebraicProduct(0.943,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000638778
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.324/SlowRight + 0.000/VSlowRight + 0.971/Zero + 0.008/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.057,VSlowLeft),AlgebraicProduct(0.943,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 56.604198, rot-vel: 0.036599}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1275.297729, DeltaTheta: 0.057185}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.275
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1270.690063, DeltaTheta: 0.034660}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.271
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1266.566895, DeltaTheta: 0.034773}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.267
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1262.399170, DeltaTheta: 0.031141}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.262
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:47]: {Distance: 1256.679077, DeltaTheta: 0.031683}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.257
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:47]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1250.354492, DeltaTheta: 0.119727}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.250
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.393/Zero + 0.607/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.607] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.607,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.607,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.393] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.393,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.393,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.601
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.820/MediumForward + 0.180/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.607,Zero),AlgebraicProduct(0.393,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0103812
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.176/SlowRight + 0.000/VSlowRight + 0.528/Zero + 0.130/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.607,VSlowLeft),AlgebraicProduct(0.393,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 23.600956, rot-vel: 0.594800}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1243.300293, DeltaTheta: 0.104742}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.243
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.594/Zero + 0.406/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.406] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.406,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.406,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.594] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.594,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.594,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 35.6728
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.216/MediumForward + 0.784/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.406,Zero),AlgebraicProduct(0.594,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00588835
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.244/SlowRight + 0.000/VSlowRight + 0.732/Zero + 0.074/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.406,VSlowLeft),AlgebraicProduct(0.594,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 35.672763, rot-vel: 0.337378}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1237.217529, DeltaTheta: 0.105257}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.237
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.587/Zero + 0.413/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.413] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.587] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 35.2582
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.237/MediumForward + 0.763/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.413,Zero),AlgebraicProduct(0.587,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00602099
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.242/SlowRight + 0.000/VSlowRight + 0.726/Zero + 0.075/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.413,VSlowLeft),AlgebraicProduct(0.587,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 35.258183, rot-vel: 0.344977}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1234.095337, DeltaTheta: 0.009778}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.234
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1232.534912, DeltaTheta: 0.088887}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.233
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.807/Zero + 0.193/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.193] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.807] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 48.4278
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.579/Forward + 0.421/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,Zero),AlgebraicProduct(0.807,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00239207
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.297/SlowRight + 0.000/VSlowRight + 0.891/Zero + 0.030/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,VSlowLeft),AlgebraicProduct(0.807,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 48.427788, rot-vel: 0.137055}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1229.230957, DeltaTheta: 0.098275}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.229
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.681/Zero + 0.319/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.319] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.319,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.319,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.681] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.681,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.681,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.8773
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.956/Forward + 0.044/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.319,Zero),AlgebraicProduct(0.681,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00433244
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.268/SlowRight + 0.000/VSlowRight + 0.803/Zero + 0.054/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.319,VSlowLeft),AlgebraicProduct(0.681,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 40.877254, rot-vel: 0.248231}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1224.328003, DeltaTheta: 0.123058}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.224
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.348/Zero + 0.652/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.652] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.652,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.652,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.348] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.348,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.348,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.9158
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.954/MediumForward + 0.046/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.652,Zero),AlgebraicProduct(0.348,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0115882
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.158/SlowRight + 0.000/VSlowRight + 0.473/Zero + 0.145/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.652,VSlowLeft),AlgebraicProduct(0.348,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 20.915768, rot-vel: 0.663957}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1219.444946, DeltaTheta: 0.147324}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.219
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.022/Zero + 0.978/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.978] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.022] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.32894
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.311/Backwards + 0.000/MediumBackwards + 0.934/Zero + 0.066/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.978,Zero),AlgebraicProduct(0.022,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0238661
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.298/VSlowLeft + 0.085/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.978,VSlowLeft),AlgebraicProduct(0.022,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 1.328937, rot-vel: 1.367425}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1213.494995, DeltaTheta: 0.254267}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.213
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.752/PNear + 0.248/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.752] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.248] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.77128e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,Zero),AlgebraicProduct(0.248,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0327897
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.410/VSlowLeft + 0.490/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,VSlowLeft),AlgebraicProduct(0.248,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: -0.000000, rot-vel: 1.878713}
[ DORIS] [2018-03-14 16:29:48]: {Distance: 1211.328003, DeltaTheta: 0.120986}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.211
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.376/Zero + 0.624/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.624] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.624,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.376] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.376,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.5863
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.871/MediumForward + 0.129/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,Zero),AlgebraicProduct(0.376,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0108271
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.169/SlowRight + 0.000/VSlowRight + 0.508/Zero + 0.135/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.624,VSlowLeft),AlgebraicProduct(0.376,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:48]: {lin-vel: 22.586295, rot-vel: 0.620347}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1211.974976, DeltaTheta: 0.083696}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.212
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.876/Zero + 0.124/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.124] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.124,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.124,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.876] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.876,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.876,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.6002
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.370/Forward + 0.630/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.124,Zero),AlgebraicProduct(0.876,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00145685
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.311/SlowRight + 0.000/VSlowRight + 0.934/Zero + 0.018/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.124,VSlowLeft),AlgebraicProduct(0.876,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 52.600198, rot-vel: 0.083472}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1209.793823, DeltaTheta: -0.065919}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1206.330322, DeltaTheta: -0.040624}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.206
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1202.330322, DeltaTheta: 0.047049}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.202
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1194.509644, DeltaTheta: 0.032290}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.195
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1186.447388, DeltaTheta: -0.143411}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.186
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.925/NNear + 0.075/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.925] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.925,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.925,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.075] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.075,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.075,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.49053
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.258/Backwards + 0.000/MediumBackwards + 0.775/Zero + 0.225/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.925,Zero),AlgebraicProduct(0.075,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0202101
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.640/SlowRight + 0.919/VSlowRight + 0.081/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.925,VSlowRight),AlgebraicProduct(0.075,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 4.490534, rot-vel: -1.157954}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1179.503418, DeltaTheta: -0.241691}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.219/NFar + 0.781/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.219] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.219,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.219,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.781] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.781,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.781,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.39971e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.219,Zero),AlgebraicProduct(0.781,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0242961
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.701/SlowRight + 0.896/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.219,SlowRight),AlgebraicProduct(0.781,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: -0.000000, rot-vel: -1.392062}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1174.868286, DeltaTheta: -0.240777}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.175
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.217/NFar + 0.783/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.217] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.217,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.217,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.783] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.783,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.783,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.28838e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.217,Zero),AlgebraicProduct(0.783,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0242727
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.701/SlowRight + 0.897/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.217,SlowRight),AlgebraicProduct(0.783,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: -0.000000, rot-vel: -1.390723}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1173.868286, DeltaTheta: 0.109818}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.526/Zero + 0.474/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.474] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.474,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.474,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.526] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.526,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.526,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 31.5858
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.421/MediumForward + 0.579/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.474,Zero),AlgebraicProduct(0.526,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00725753
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.223/SlowRight + 0.000/VSlowRight + 0.670/Zero + 0.091/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.474,VSlowLeft),AlgebraicProduct(0.526,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: 31.585847, rot-vel: 0.415826}
[ DORIS] [2018-03-14 16:29:49]: {Distance: 1173.255127, DeltaTheta: 0.187499}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.173
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.909/PNear + 0.091/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.909] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.909,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.909,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.091] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.091,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.091,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.93863e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.909,Zero),AlgebraicProduct(0.091,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0282468
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.353/VSlowLeft + 0.284/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.909,VSlowLeft),AlgebraicProduct(0.091,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:49]: {lin-vel: -0.000000, rot-vel: 1.618422}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1173.255127, DeltaTheta: 0.099836}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.173
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.660/Zero + 0.340/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.340] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.340,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.340,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.660] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.660,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.660,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 39.6212
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.019/MediumForward + 0.981/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.340,Zero),AlgebraicProduct(0.660,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0046902
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.262/SlowRight + 0.000/VSlowRight + 0.787/Zero + 0.059/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.340,VSlowLeft),AlgebraicProduct(0.660,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 39.621248, rot-vel: 0.268729}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1170.060791, DeltaTheta: 0.212578}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.170
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.850/PNear + 0.150/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.850] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.850,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.850,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.150] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.150,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.150,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.57165e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.850,Zero),AlgebraicProduct(0.150,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0301002
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.376/VSlowLeft + 0.368/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.850,VSlowLeft),AlgebraicProduct(0.150,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: -0.000000, rot-vel: 1.724617}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1166.872192, DeltaTheta: 0.135130}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.167
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.186/Zero + 0.814/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.814] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.814,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.814,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.186] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.186,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.186,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.1769
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.147/Backwards + 0.000/MediumBackwards + 0.441/Zero + 0.559/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.814,Zero),AlgebraicProduct(0.186,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0168053
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.079/SlowRight + 0.000/VSlowRight + 0.236/Zero + 0.210/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.814,VSlowLeft),AlgebraicProduct(0.186,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 11.176938, rot-vel: 0.962875}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1163.709839, DeltaTheta: 0.047716}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.164
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1161.541138, DeltaTheta: -0.032325}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.162
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1158.166870, DeltaTheta: -0.028416}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.158
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1155.728027, DeltaTheta: -0.001570}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.156
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1151.592651, DeltaTheta: 0.107699}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.152
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.554/Zero + 0.446/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.446] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.446,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.446,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.554] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.554,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.554,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.2919
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.335/MediumForward + 0.665/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.446,Zero),AlgebraicProduct(0.554,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00666898
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.232/SlowRight + 0.000/VSlowRight + 0.697/Zero + 0.083/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.446,VSlowLeft),AlgebraicProduct(0.554,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 33.291857, rot-vel: 0.382104}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1143.530396, DeltaTheta: 0.020487}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.144
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:50]: {Distance: 1138.222290, DeltaTheta: 0.002532}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.138
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:50]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1133.842041, DeltaTheta: 0.076138}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.134
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.978/Zero + 0.022/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.022] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.022,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.978] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.978,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 58.6721
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.066/Forward + 0.934/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.022,Zero),AlgebraicProduct(0.978,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000244092
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.330/SlowRight + 0.000/VSlowRight + 0.989/Zero + 0.003/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.022,VSlowLeft),AlgebraicProduct(0.978,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 58.672064, rot-vel: 0.013985}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1128.743042, DeltaTheta: -0.011378}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.129
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1123.613037, DeltaTheta: -0.012762}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.124
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1117.902710, DeltaTheta: 0.075349}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.118
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.988/Zero + 0.012/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.012] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.988] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 59.3061
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.035/Forward + 0.965/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.012,Zero),AlgebraicProduct(0.988,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000126655
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.331/SlowRight + 0.000/VSlowRight + 0.994/Zero + 0.002/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.012,VSlowLeft),AlgebraicProduct(0.988,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 59.306102, rot-vel: 0.007257}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1111.819946, DeltaTheta: 0.075761}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.112
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.983/Zero + 0.017/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.017] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.983] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 58.9751
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.051/Forward + 0.949/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.017,Zero),AlgebraicProduct(0.983,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000187764
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.330/SlowRight + 0.000/VSlowRight + 0.991/Zero + 0.002/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.017,VSlowLeft),AlgebraicProduct(0.983,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 58.975070, rot-vel: 0.010758}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1105.147827, DeltaTheta: 0.163772}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.105
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.965/PNear + 0.035/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.965] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.965,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.965,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.035] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.035,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.035,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.51142e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.965,Zero),AlgebraicProduct(0.035,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0263086
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.329/VSlowLeft + 0.196/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.965,VSlowLeft),AlgebraicProduct(0.035,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: -0.000000, rot-vel: 1.507374}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1098.619019, DeltaTheta: 0.155568}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.099
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.984/PNear + 0.016/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.984] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.016] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.58506e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,Zero),AlgebraicProduct(0.016,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0255932
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.320/VSlowLeft + 0.163/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,VSlowLeft),AlgebraicProduct(0.016,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: -0.000000, rot-vel: 1.466384}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1093.864746, DeltaTheta: 0.252037}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.757/PNear + 0.243/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.757] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.757,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.757,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.243] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.243,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.243,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.84321e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.757,Zero),AlgebraicProduct(0.243,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0326571
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.408/VSlowLeft + 0.484/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.757,VSlowLeft),AlgebraicProduct(0.243,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: -0.000000, rot-vel: 1.871117}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1092.995728, DeltaTheta: 0.113946}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.093
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.470/Zero + 0.530/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.530] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.470] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 28.2599
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.587/MediumForward + 0.413/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.530,Zero),AlgebraicProduct(0.470,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0084807
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.205/SlowRight + 0.000/VSlowRight + 0.615/Zero + 0.106/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.530,VSlowLeft),AlgebraicProduct(0.470,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 28.259901, rot-vel: 0.485908}
[ DORIS] [2018-03-14 16:29:51]: {Distance: 1093.734131, DeltaTheta: 0.061556}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:51]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1092.769897, DeltaTheta: -0.027466}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.093
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1088.746704, DeltaTheta: 0.091285}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.089
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.774/Zero + 0.226/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.226] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.226,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.226,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.774] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.774,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.774,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.4998
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.675/Forward + 0.325/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.226,Zero),AlgebraicProduct(0.774,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00285544
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.290/SlowRight + 0.000/VSlowRight + 0.870/Zero + 0.036/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.226,VSlowLeft),AlgebraicProduct(0.774,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 46.499787, rot-vel: 0.163605}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1083.647705, DeltaTheta: 0.003846}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1076.880127, DeltaTheta: -0.001837}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.077
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1068.633911, DeltaTheta: -0.001851}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.069
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1064.898193, DeltaTheta: -0.126796}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.065
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.702/NNear + 0.298/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.702] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.702,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.702,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.298] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.298,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.298,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 17.901
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.035/Backwards + 0.000/MediumBackwards + 0.105/Zero + 0.895/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.702,Zero),AlgebraicProduct(0.298,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0154772
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.568/SlowRight + 0.704/VSlowRight + 0.296/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.702,VSlowRight),AlgebraicProduct(0.298,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 17.901033, rot-vel: -0.886776}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1059.453125, DeltaTheta: -0.220609}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.059
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.169/NFar + 0.831/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.169] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.169,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.169,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.831] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.831,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.831,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.18988e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.169,Zero),AlgebraicProduct(0.831,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0237426
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.693/SlowRight + 0.921/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.169,SlowRight),AlgebraicProduct(0.831,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: -0.000000, rot-vel: -1.360348}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1055.811768, DeltaTheta: -0.058147}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.056
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1054.390381, DeltaTheta: 0.023545}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.054
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:52]: {Distance: 1053.390381, DeltaTheta: 0.023567}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.053
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:52]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1048.820312, DeltaTheta: 0.040016}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.049
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1043.679321, DeltaTheta: 0.226987}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.044
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.816/PNear + 0.184/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.816] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.816,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.816,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.184] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.184,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.184,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.53824e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.816,Zero),AlgebraicProduct(0.184,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0310821
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.389/VSlowLeft + 0.413/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.816,VSlowLeft),AlgebraicProduct(0.184,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: 1.780871}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1035.433228, DeltaTheta: 0.316806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.035
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.604/PNear + 0.396/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.604] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.396] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.40409e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.604,Zero),AlgebraicProduct(0.396,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0360566
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.451/VSlowLeft + 0.639/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.604,VSlowLeft),AlgebraicProduct(0.396,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: 2.065891}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1030.270996, DeltaTheta: 0.292819}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.030
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.661/PNear + 0.339/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.661] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.661,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.661,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.339] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.339,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.339,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.35825e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.661,Zero),AlgebraicProduct(0.339,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0349008
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.436/VSlowLeft + 0.586/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.661,VSlowLeft),AlgebraicProduct(0.339,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: 1.999670}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1027.825317, DeltaTheta: 0.109157}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.028
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.535/Zero + 0.465/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.465] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.535] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 32.118
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.394/MediumForward + 0.606/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,Zero),AlgebraicProduct(0.535,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00707124
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.226/SlowRight + 0.000/VSlowRight + 0.679/Zero + 0.088/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,VSlowLeft),AlgebraicProduct(0.535,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: 32.117981, rot-vel: 0.405152}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1027.825317, DeltaTheta: -0.153831}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.028
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.011/NFar + 0.989/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.011] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.011,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.011,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.989] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.989,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.989,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.64922e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.011,Zero),AlgebraicProduct(0.989,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.021815
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.664/SlowRight + 0.992/VSlowRight + 0.008/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.011,SlowRight),AlgebraicProduct(0.989,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: -1.249908}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1026.782227, DeltaTheta: -0.298949}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.027
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.354/NFar + 0.646/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.354] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.354,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.354,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.646] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.646,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.646,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.36752e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.354,Zero),AlgebraicProduct(0.646,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0256358
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.722/SlowRight + 0.835/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.354,SlowRight),AlgebraicProduct(0.646,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: -1.468820}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1027.782227, DeltaTheta: -0.211038}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.028
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.146/NFar + 0.854/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.146] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.854] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.09718e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.146,Zero),AlgebraicProduct(0.854,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0234815
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.689/SlowRight + 0.933/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.146,SlowRight),AlgebraicProduct(0.854,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: -0.000000, rot-vel: -1.345393}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1024.103882, DeltaTheta: 0.000780}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.024
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:53]: {Distance: 1021.472717, DeltaTheta: -0.013945}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.021
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:53]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 1019.405518, DeltaTheta: -0.018997}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.019
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 1017.356079, DeltaTheta: 0.067408}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.017
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 1012.038696, DeltaTheta: 0.158041}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.012
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.979/PNear + 0.021/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.979] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.021] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.8901e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,Zero),AlgebraicProduct(0.021,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0258115
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.323/VSlowLeft + 0.173/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,VSlowLeft),AlgebraicProduct(0.021,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: -0.000000, rot-vel: 1.478888}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 1003.792480, DeltaTheta: 0.159340}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 1.004
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.976/PNear + 0.024/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.976] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.024] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.86664e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.976,Zero),AlgebraicProduct(0.024,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0259251
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.324/VSlowLeft + 0.178/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.976,VSlowLeft),AlgebraicProduct(0.024,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 0.000000, rot-vel: 1.485401}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 998.689392, DeltaTheta: 0.131771}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.999
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.231/Zero + 0.769/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.769] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.769,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.769,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.231] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.231,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.231,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 13.8881
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.102/Backwards + 0.000/MediumBackwards + 0.306/Zero + 0.694/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.769,Zero),AlgebraicProduct(0.231,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0152045
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.103/SlowRight + 0.000/VSlowRight + 0.309/Zero + 0.190/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.769,VSlowLeft),AlgebraicProduct(0.231,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 13.888091, rot-vel: 0.871155}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 995.527100, DeltaTheta: 0.044387}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.996
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 996.282532, DeltaTheta: -0.057116}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.996
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 995.327209, DeltaTheta: -0.015091}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.995
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 995.156982, DeltaTheta: 0.003863}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.995
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:54]: {Distance: 987.938721, DeltaTheta: 0.122153}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.988
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.360/Zero + 0.640/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.640] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.360] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.6452
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.918/MediumForward + 0.082/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.640,Zero),AlgebraicProduct(0.360,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0112516
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.163/SlowRight + 0.000/VSlowRight + 0.489/Zero + 0.141/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.640,VSlowLeft),AlgebraicProduct(0.360,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:54]: {lin-vel: 21.645243, rot-vel: 0.644671}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 977.740662, DeltaTheta: 0.035308}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.978
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 972.634644, DeltaTheta: -0.081529}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.973
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.095/NNear + 0.905/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.095] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.095,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.095,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.905] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.905,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.905,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.3416
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.283/Forward + 0.717/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.095,Zero),AlgebraicProduct(0.905,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00189143
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.362/SlowRight + 0.086/VSlowRight + 0.914/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.095,VSlowRight),AlgebraicProduct(0.905,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 54.341596, rot-vel: -0.108371}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 970.371887, DeltaTheta: -0.022714}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.970
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 966.683960, DeltaTheta: 0.075925}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.967
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.981/Zero + 0.019/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.019] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.019,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.019,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.981] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.981,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.981,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 58.843
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.058/Forward + 0.942/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.019,Zero),AlgebraicProduct(0.981,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000212274
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.330/SlowRight + 0.000/VSlowRight + 0.990/Zero + 0.003/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.019,VSlowLeft),AlgebraicProduct(0.981,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 58.842972, rot-vel: 0.012162}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 964.795715, DeltaTheta: -0.010474}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.965
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 958.198303, DeltaTheta: -0.005634}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.958
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 950.460632, DeltaTheta: 0.061440}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.950
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 945.366699, DeltaTheta: 0.109416}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.945
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.531/Zero + 0.469/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.469] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.531] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 31.9092
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.405/MediumForward + 0.595/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,Zero),AlgebraicProduct(0.531,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00714402
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.225/SlowRight + 0.000/VSlowRight + 0.675/Zero + 0.089/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,VSlowLeft),AlgebraicProduct(0.531,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: 31.909238, rot-vel: 0.409322}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 939.330078, DeltaTheta: 0.186180}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.939
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.912/PNear + 0.088/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.912] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.912,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.088] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.088,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.20391e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,Zero),AlgebraicProduct(0.088,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.028144
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.352/VSlowLeft + 0.279/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.912,VSlowLeft),AlgebraicProduct(0.088,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: -0.000000, rot-vel: 1.612531}
[ DORIS] [2018-03-14 16:29:55]: {Distance: 935.206970, DeltaTheta: 0.187001}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.935
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.910/PNear + 0.090/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.910] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.910,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.910,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.090] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.26197e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.910,Zero),AlgebraicProduct(0.090,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.028208
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.353/VSlowLeft + 0.282/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.910,VSlowLeft),AlgebraicProduct(0.090,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:55]: {lin-vel: -0.000000, rot-vel: 1.616202}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 932.174561, DeltaTheta: 0.293793}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.932
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.658/PNear + 0.342/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.658] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.342] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.5984e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.658,Zero),AlgebraicProduct(0.342,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.03495
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.437/VSlowLeft + 0.589/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.658,VSlowLeft),AlgebraicProduct(0.342,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: -0.000000, rot-vel: 2.002487}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 930.778015, DeltaTheta: 0.137823}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.931
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.150/Zero + 0.850/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.850] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.850,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.850,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.150] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.150,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.150,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 9.00287
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.183/Backwards + 0.000/MediumBackwards + 0.550/Zero + 0.450/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.850,Zero),AlgebraicProduct(0.150,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.018185
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.058/SlowRight + 0.000/VSlowRight + 0.173/Zero + 0.227/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.850,VSlowLeft),AlgebraicProduct(0.150,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 9.002871, rot-vel: 1.041926}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 931.778015, DeltaTheta: -0.037556}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.932
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 929.947632, DeltaTheta: -0.255116}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.930
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.250/NFar + 0.750/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.250] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.250,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.250,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.750] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.750,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.750,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.03328e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.250,Zero),AlgebraicProduct(0.750,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0246322
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.707/SlowRight + 0.880/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.250,SlowRight),AlgebraicProduct(0.750,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 0.000000, rot-vel: -1.411321}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 929.638184, DeltaTheta: -0.326507}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.930
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.419/NFar + 0.581/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.419] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.419,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.419,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.581] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.581,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.581,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.20513e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.419,Zero),AlgebraicProduct(0.581,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0261907
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.730/SlowRight + 0.810/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.419,SlowRight),AlgebraicProduct(0.581,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: -0.000000, rot-vel: -1.500615}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 925.488098, DeltaTheta: -0.214732}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.925
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.155/NFar + 0.845/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.155] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.155,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.155,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.845] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.845,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.845,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.15438e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.155,Zero),AlgebraicProduct(0.845,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.023583
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.691/SlowRight + 0.928/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.155,SlowRight),AlgebraicProduct(0.845,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: -0.000000, rot-vel: -1.351205}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 923.662537, DeltaTheta: -0.124069}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.924
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.666/NNear + 0.334/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.666] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.334] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.1005
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.995/MediumForward + 0.005/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,Zero),AlgebraicProduct(0.334,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0146593
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.555/SlowRight + 0.666/VSlowRight + 0.334/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.666,VSlowRight),AlgebraicProduct(0.334,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 20.100473, rot-vel: -0.839913}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 922.266052, DeltaTheta: -0.068998}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.922
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 922.160767, DeltaTheta: -0.006678}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.922
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:56]: {Distance: 919.527954, DeltaTheta: 0.012179}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.920
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:56]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 915.546387, DeltaTheta: 0.002785}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.916
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 908.065247, DeltaTheta: 0.076401}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.908
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.974/Zero + 0.026/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.026] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.026,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.974] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.974,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 58.4608
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.077/Forward + 0.923/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,Zero),AlgebraicProduct(0.974,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000283597
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.329/SlowRight + 0.000/VSlowRight + 0.987/Zero + 0.004/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.026,VSlowLeft),AlgebraicProduct(0.974,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: 58.460764, rot-vel: 0.016249}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 898.845764, DeltaTheta: 0.165297}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.899
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.961/PNear + 0.039/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.961] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.039] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.12964e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,Zero),AlgebraicProduct(0.039,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.026439
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.330/VSlowLeft + 0.202/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,VSlowLeft),AlgebraicProduct(0.039,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: 1.514841}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 894.475647, DeltaTheta: 0.207301}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.894
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.862/PNear + 0.138/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.862] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.862,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.862,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.138] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.138,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.138,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.4127e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.862,Zero),AlgebraicProduct(0.138,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0297259
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.372/VSlowLeft + 0.351/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.862,VSlowLeft),AlgebraicProduct(0.138,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: 1.703169}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 891.730103, DeltaTheta: 0.185846}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.892
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.913/PNear + 0.087/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.913] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.087] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.62472e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.913,Zero),AlgebraicProduct(0.087,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0281178
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.351/VSlowLeft + 0.278/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.913,VSlowLeft),AlgebraicProduct(0.087,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: 1.611032}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 890.730103, DeltaTheta: -0.164792}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.891
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.037/NFar + 0.963/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.037] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.037,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.037,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.963] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.963,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.963,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.22052e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.037,Zero),AlgebraicProduct(0.963,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0221463
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.669/SlowRight + 0.993/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.037,SlowRight),AlgebraicProduct(0.963,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: -1.268890}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 890.919495, DeltaTheta: -0.340727}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.891
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.452/NFar + 0.548/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.452] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.548] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.25198e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,Zero),AlgebraicProduct(0.548,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.026454
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.734/SlowRight + 0.798/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,SlowRight),AlgebraicProduct(0.548,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: -1.515704}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 891.329712, DeltaTheta: -0.310407}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.891
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.381/NFar + 0.619/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.381] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.381,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.381,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.619] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.619,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.619,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.94579e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.381,Zero),AlgebraicProduct(0.619,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0258736
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.725/SlowRight + 0.824/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.381,SlowRight),AlgebraicProduct(0.619,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: -0.000000, rot-vel: -1.482451}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 892.693604, DeltaTheta: -0.209683}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.893
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.143/NFar + 0.857/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.143] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.143,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.143,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.857] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.857,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.857,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.13234e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.143,Zero),AlgebraicProduct(0.857,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0234441
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.689/SlowRight + 0.934/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.143,SlowRight),AlgebraicProduct(0.857,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: 0.000000, rot-vel: -1.343248}
[ DORIS] [2018-03-14 16:29:57]: {Distance: 891.960632, DeltaTheta: -0.122600}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.892
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.646/NNear + 0.354/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.646] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.646,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.646,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.354] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.354,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.354,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.2848
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.936/MediumForward + 0.064/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.646,Zero),AlgebraicProduct(0.354,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0142155
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.549/SlowRight + 0.646/VSlowRight + 0.354/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.646,VSlowRight),AlgebraicProduct(0.354,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:57]: {lin-vel: 21.284787, rot-vel: -0.814485}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 889.884216, DeltaTheta: -0.070053}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.890
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 889.554199, DeltaTheta: 0.016963}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.890
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 887.942871, DeltaTheta: 0.012856}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.888
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 884.246399, DeltaTheta: 0.014594}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.884
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 879.687927, DeltaTheta: 0.071543}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.880
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 875.080994, DeltaTheta: 0.033139}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.875
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 869.497498, DeltaTheta: 0.028029}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.869
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 864.859863, DeltaTheta: 0.007894}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.865
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 861.329529, DeltaTheta: 0.090018}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.861
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.791/Zero + 0.209/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.209] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.791] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 47.5185
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.624/Forward + 0.376/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,Zero),AlgebraicProduct(0.791,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00260804
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.294/SlowRight + 0.000/VSlowRight + 0.881/Zero + 0.033/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,VSlowLeft),AlgebraicProduct(0.791,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 47.518471, rot-vel: 0.149429}
[ DORIS] [2018-03-14 16:29:58]: {Distance: 856.230530, DeltaTheta: 0.090555}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.856
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.784/Zero + 0.216/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.216] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.784] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 47.0874
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.646/Forward + 0.354/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.216,Zero),AlgebraicProduct(0.784,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00271201
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.292/SlowRight + 0.000/VSlowRight + 0.877/Zero + 0.034/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.216,VSlowLeft),AlgebraicProduct(0.784,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:58]: {lin-vel: 47.087437, rot-vel: 0.155386}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 851.035889, DeltaTheta: 0.173959}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.851
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.941/PNear + 0.059/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.941] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.941,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.941,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.059] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.059,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.059,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.35015e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.941,Zero),AlgebraicProduct(0.059,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.027164
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.340/VSlowLeft + 0.235/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.941,VSlowLeft),AlgebraicProduct(0.059,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: 1.556382}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 846.831543, DeltaTheta: 0.165992}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.847
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.960/PNear + 0.040/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.960] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.960,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.960,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.040] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.040,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.040,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.40344e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.960,Zero),AlgebraicProduct(0.040,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0264981
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.331/VSlowLeft + 0.204/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.960,VSlowLeft),AlgebraicProduct(0.040,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: 1.518228}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 843.046631, DeltaTheta: 0.153150}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.843
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.990/PNear + 0.010/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.990] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.010] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.81279e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.990,Zero),AlgebraicProduct(0.010,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0253778
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.317/VSlowLeft + 0.154/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.990,VSlowLeft),AlgebraicProduct(0.010,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: 1.454039}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 842.660278, DeltaTheta: 0.215975}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.843
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.842/PNear + 0.158/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.842] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.842,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.842,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.158] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.158,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.158,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.41053e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.842,Zero),AlgebraicProduct(0.158,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0303369
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.379/VSlowLeft + 0.379/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.842,VSlowLeft),AlgebraicProduct(0.158,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: 1.738176}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 843.627380, DeltaTheta: 0.046310}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.844
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 843.895996, DeltaTheta: -0.180371}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.844
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.074/NFar + 0.926/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.074] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.074,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.074,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.926] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.926,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.926,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.82033e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.074,Zero),AlgebraicProduct(0.926,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0226084
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.676/SlowRight + 0.972/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.074,SlowRight),AlgebraicProduct(0.926,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: -1.295368}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 843.294556, DeltaTheta: -0.408554}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.843
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.612/NFar + 0.388/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.612] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.612,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.612,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.388] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.388,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.388,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.20594e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.612,Zero),AlgebraicProduct(0.388,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0275036
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.750/SlowRight + 0.750/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.612,SlowRight),AlgebraicProduct(0.388,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: -1.575842}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 840.365662, DeltaTheta: -0.156119}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.840
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.017/NFar + 0.983/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.017] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.017,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.983] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.983,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.00333e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.017,Zero),AlgebraicProduct(0.983,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0218845
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.665/SlowRight + 0.995/VSlowRight + 0.005/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.017,SlowRight),AlgebraicProduct(0.983,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: -1.253892}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 836.915710, DeltaTheta: -0.107954}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.837
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.449/NNear + 0.551/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.449] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.449,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.449,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.551] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.551,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.551,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.0867
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.346/MediumForward + 0.654/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.449,Zero),AlgebraicProduct(0.551,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00972012
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.481/SlowRight + 0.442/VSlowRight + 0.558/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.449,VSlowRight),AlgebraicProduct(0.551,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: 33.086668, rot-vel: -0.556922}
[ DORIS] [2018-03-14 16:29:59]: {Distance: 834.373169, DeltaTheta: -0.153035}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.834
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.010/NFar + 0.990/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.010] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.990] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.0897e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.010,Zero),AlgebraicProduct(0.990,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0217908
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.663/SlowRight + 0.990/VSlowRight + 0.010/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.010,SlowRight),AlgebraicProduct(0.990,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:29:59]: {lin-vel: -0.000000, rot-vel: -1.248520}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 834.057312, DeltaTheta: -0.176276}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.834
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.064/NFar + 0.936/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.24602e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,Zero),AlgebraicProduct(0.936,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.022488
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.674/SlowRight + 0.978/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,SlowRight),AlgebraicProduct(0.936,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: -0.000000, rot-vel: -1.288469}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 832.917175, DeltaTheta: -0.003193}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.833
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 832.886414, DeltaTheta: -0.028074}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.833
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 830.743225, DeltaTheta: 0.035644}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.831
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 829.273438, DeltaTheta: 0.099868}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.829
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.659/Zero + 0.341/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.341] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.659] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 39.5954
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.020/MediumForward + 0.980/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,Zero),AlgebraicProduct(0.659,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00469767
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.262/SlowRight + 0.000/VSlowRight + 0.786/Zero + 0.059/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,VSlowLeft),AlgebraicProduct(0.659,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 39.595425, rot-vel: 0.269156}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 824.163940, DeltaTheta: 0.089100}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.824
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.804/Zero + 0.196/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.196] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.196,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.196,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.804] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.804,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.804,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 48.2571
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.587/Forward + 0.413/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.196,Zero),AlgebraicProduct(0.804,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00243227
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.296/SlowRight + 0.000/VSlowRight + 0.889/Zero + 0.030/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.196,VSlowLeft),AlgebraicProduct(0.804,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 48.257079, rot-vel: 0.139359}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 817.092896, DeltaTheta: 0.177913}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.817
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.932/PNear + 0.068/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.932] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.932,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.068] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.068,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.0544e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.932,Zero),AlgebraicProduct(0.068,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0274864
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.344/VSlowLeft + 0.249/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.932,VSlowLeft),AlgebraicProduct(0.068,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: -0.000000, rot-vel: 1.574855}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 813.641602, DeltaTheta: 0.092097}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.814
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.764/Zero + 0.236/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.236] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.236,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.236,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.764] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.764,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.764,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 45.8472
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.708/Forward + 0.292/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.236,Zero),AlgebraicProduct(0.764,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00301704
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.288/SlowRight + 0.000/VSlowRight + 0.863/Zero + 0.038/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.236,VSlowLeft),AlgebraicProduct(0.764,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 45.847188, rot-vel: 0.172864}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 810.193176, DeltaTheta: 0.070073}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.810
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:00]: {Distance: 810.713623, DeltaTheta: -0.045882}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.811
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:00]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 808.593872, DeltaTheta: -0.131459}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.809
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.765/NNear + 0.235/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.765] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.765,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.235] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.235,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 14.1399
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.098/Backwards + 0.000/MediumBackwards + 0.293/Zero + 0.707/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,Zero),AlgebraicProduct(0.235,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0168532
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.589/SlowRight + 0.766/VSlowRight + 0.234/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.765,VSlowRight),AlgebraicProduct(0.235,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 14.139884, rot-vel: -0.965615}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 804.007568, DeltaTheta: 0.042638}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.804
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 799.841064, DeltaTheta: 0.042861}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.800
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 796.400574, DeltaTheta: -0.015161}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.796
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 790.854370, DeltaTheta: 0.066353}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.791
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 789.369507, DeltaTheta: 0.048545}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.789
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 784.369507, DeltaTheta: 0.048854}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.784
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 779.647278, DeltaTheta: 0.023443}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.780
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 773.470886, DeltaTheta: 0.016717}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.773
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:01]: {Distance: 766.399841, DeltaTheta: 0.104938}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.766
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.591/Zero + 0.409/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.409] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.409,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.409,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.591] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.591,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.591,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 35.5148
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.224/MediumForward + 0.776/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.409,Zero),AlgebraicProduct(0.591,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00593873
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.243/SlowRight + 0.000/VSlowRight + 0.730/Zero + 0.074/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.409,VSlowLeft),AlgebraicProduct(0.591,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:01]: {lin-vel: 35.514784, rot-vel: 0.340264}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 761.726868, DeltaTheta: 0.104723}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.762
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.594/Zero + 0.406/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.406] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.406,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.406,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.594] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.594,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.594,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 35.6885
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.216/MediumForward + 0.784/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.406,Zero),AlgebraicProduct(0.594,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00588335
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.244/SlowRight + 0.000/VSlowRight + 0.733/Zero + 0.074/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.406,VSlowLeft),AlgebraicProduct(0.594,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 35.688466, rot-vel: 0.337091}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 757.681519, DeltaTheta: 0.085505}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.758
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.852/Zero + 0.148/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.148] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.852] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 51.1469
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.443/Forward + 0.557/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,Zero),AlgebraicProduct(0.852,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00177255
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.306/SlowRight + 0.000/VSlowRight + 0.919/Zero + 0.022/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.148,VSlowLeft),AlgebraicProduct(0.852,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 51.146897, rot-vel: 0.101559}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 754.091553, DeltaTheta: 0.176231}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.754
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.936/PNear + 0.064/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.64258e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,Zero),AlgebraicProduct(0.064,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0273499
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.342/VSlowLeft + 0.243/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.936,VSlowLeft),AlgebraicProduct(0.064,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: -0.000000, rot-vel: 1.567035}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 751.705505, DeltaTheta: 0.165489}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.752
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.961/PNear + 0.039/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.961] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.961,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.039] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.039,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.26295e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,Zero),AlgebraicProduct(0.039,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0264553
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.331/VSlowLeft + 0.203/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.961,VSlowLeft),AlgebraicProduct(0.039,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: -0.000000, rot-vel: 1.515778}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 748.512512, DeltaTheta: 0.090086}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.749
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.791/Zero + 0.209/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.209] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.791] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 47.4639
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.627/Forward + 0.373/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,Zero),AlgebraicProduct(0.791,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00262115
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.294/SlowRight + 0.000/VSlowRight + 0.881/Zero + 0.033/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,VSlowLeft),AlgebraicProduct(0.791,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 47.463855, rot-vel: 0.150181}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 746.949707, DeltaTheta: -0.053561}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.747
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 745.473877, DeltaTheta: -0.251671}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.745
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.242/NFar + 0.758/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.242] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.242,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.242,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.758] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.758,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.758,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.50037e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.242,Zero),AlgebraicProduct(0.758,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0245472
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.705/SlowRight + 0.884/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.242,SlowRight),AlgebraicProduct(0.758,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: -0.000000, rot-vel: -1.406452}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 742.369751, DeltaTheta: -0.151146}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.742
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.005/NFar + 0.995/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.005] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.995] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.96299e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,Zero),AlgebraicProduct(0.995,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0217332
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.663/SlowRight + 0.988/VSlowRight + 0.012/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,SlowRight),AlgebraicProduct(0.995,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: -0.000000, rot-vel: -1.245221}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 737.221619, DeltaTheta: 0.018035}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.737
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:02]: {Distance: 734.317810, DeltaTheta: -0.069162}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.734
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:02]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 732.703430, DeltaTheta: -0.094294}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.733
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.266/NNear + 0.734/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.266] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.266,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.266,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.734] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.734,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.734,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.0798
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.796/Forward + 0.204/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.266,Zero),AlgebraicProduct(0.734,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00556572
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.418/SlowRight + 0.253/VSlowRight + 0.747/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.266,VSlowRight),AlgebraicProduct(0.734,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 44.079844, rot-vel: -0.318893}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 729.101013, DeltaTheta: -0.011387}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.729
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 724.064453, DeltaTheta: 0.053400}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.724
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 719.184082, DeltaTheta: -0.089914}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.719
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.207/NNear + 0.793/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.207] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.207,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.207,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.793] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.793,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.793,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 47.6026
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.620/Forward + 0.380/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.207,Zero),AlgebraicProduct(0.793,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00427449
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.398/SlowRight + 0.194/VSlowRight + 0.806/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.207,VSlowRight),AlgebraicProduct(0.793,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 47.602643, rot-vel: -0.244910}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 711.438354, DeltaTheta: -0.065761}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.711
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 706.677002, DeltaTheta: 0.037405}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.707
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 700.159241, DeltaTheta: 0.130461}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.700
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.248/Zero + 0.752/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.752] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.752,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.248] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.248,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 14.9445
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.084/Backwards + 0.000/MediumBackwards + 0.253/Zero + 0.747/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,Zero),AlgebraicProduct(0.248,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0146141
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.112/SlowRight + 0.000/VSlowRight + 0.336/Zero + 0.183/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.752,VSlowLeft),AlgebraicProduct(0.248,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 14.944493, rot-vel: 0.837325}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 697.709839, DeltaTheta: 0.080966}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.698
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.913/Zero + 0.087/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.087] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.087,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.913] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.913,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.7943
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.260/Forward + 0.740/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.087,Zero),AlgebraicProduct(0.913,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00099947
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.318/SlowRight + 0.000/VSlowRight + 0.955/Zero + 0.012/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.087,VSlowLeft),AlgebraicProduct(0.913,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 54.794312, rot-vel: 0.057265}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 694.221863, DeltaTheta: 0.061072}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.694
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:03]: {Distance: 691.221863, DeltaTheta: 0.061337}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.691
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:03]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 688.590759, DeltaTheta: -0.050571}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.689
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 683.513000, DeltaTheta: 0.030772}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.684
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 677.430237, DeltaTheta: 0.031048}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.677
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 670.583984, DeltaTheta: -0.012600}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.671
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 664.841309, DeltaTheta: -0.070783}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.665
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 659.713318, DeltaTheta: -0.031452}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.660
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 656.320374, DeltaTheta: 0.006589}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.656
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 652.622681, DeltaTheta: -0.006312}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.653
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 646.539917, DeltaTheta: 0.081704}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.647
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.903/Zero + 0.097/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.097] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.097,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.097,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.903] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.903,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.903,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.2015
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.290/Forward + 0.710/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.097,Zero),AlgebraicProduct(0.903,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00112083
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.316/SlowRight + 0.000/VSlowRight + 0.949/Zero + 0.014/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.097,VSlowLeft),AlgebraicProduct(0.903,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 54.201489, rot-vel: 0.064219}
[ DORIS] [2018-03-14 16:30:04]: {Distance: 640.709534, DeltaTheta: 0.017323}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.641
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:04]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 634.766541, DeltaTheta: 0.092189}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.635
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.762/Zero + 0.238/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.238] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.238,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.762] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.762,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 45.7734
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.711/Forward + 0.289/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.238,Zero),AlgebraicProduct(0.762,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00303546
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.287/SlowRight + 0.000/VSlowRight + 0.862/Zero + 0.038/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.238,VSlowLeft),AlgebraicProduct(0.762,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 45.773425, rot-vel: 0.173919}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 628.939697, DeltaTheta: 0.039320}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.629
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 625.470459, DeltaTheta: 0.127429}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.625
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.289/Zero + 0.711/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.711] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.711,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.711,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.289] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.289,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.289,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 17.3906
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.043/Backwards + 0.000/MediumBackwards + 0.130/Zero + 0.870/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.711,Zero),AlgebraicProduct(0.289,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0133133
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.132/SlowRight + 0.000/VSlowRight + 0.395/Zero + 0.166/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.711,VSlowLeft),AlgebraicProduct(0.289,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 17.390562, rot-vel: 0.762794}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 620.621887, DeltaTheta: 0.057637}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.621
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 615.309753, DeltaTheta: 0.085905}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.615
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.847/Zero + 0.153/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.153] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.847] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 50.8251
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.459/Forward + 0.541/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.153,Zero),AlgebraicProduct(0.847,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00184388
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.305/SlowRight + 0.000/VSlowRight + 0.916/Zero + 0.023/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.153,VSlowLeft),AlgebraicProduct(0.847,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 50.825056, rot-vel: 0.105646}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 612.103027, DeltaTheta: 0.069115}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.612
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 607.000977, DeltaTheta: 0.109104}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.607
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.535/Zero + 0.465/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.465] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.535] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 32.1608
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.392/MediumForward + 0.608/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,Zero),AlgebraicProduct(0.535,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00705637
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.226/SlowRight + 0.000/VSlowRight + 0.679/Zero + 0.088/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,VSlowLeft),AlgebraicProduct(0.535,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 32.160764, rot-vel: 0.404300}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 601.484070, DeltaTheta: 0.144732}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.601
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.057/Zero + 0.943/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.943] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.943,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.943,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.057] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.057,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.057,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.42332
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.276/Backwards + 0.000/MediumBackwards + 0.829/Zero + 0.171/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.943,Zero),AlgebraicProduct(0.057,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0221762
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.277/VSlowLeft + 0.008/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.943,VSlowLeft),AlgebraicProduct(0.057,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: 3.423324, rot-vel: 1.270601}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 596.477112, DeltaTheta: 0.244470}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.596
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.775/PNear + 0.225/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.775] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.775,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.775,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.225] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.225,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.225,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.61831e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.775,Zero),AlgebraicProduct(0.225,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0321983
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.402/VSlowLeft + 0.464/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.775,VSlowLeft),AlgebraicProduct(0.225,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: -0.000000, rot-vel: 1.844825}
[ DORIS] [2018-03-14 16:30:05]: {Distance: 592.987671, DeltaTheta: 0.189659}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.593
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.904/PNear + 0.096/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.904] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.904,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.096] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.096,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.14192e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.904,Zero),AlgebraicProduct(0.096,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0284141
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.355/VSlowLeft + 0.292/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.904,VSlowLeft),AlgebraicProduct(0.096,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:05]: {lin-vel: -0.000000, rot-vel: 1.628005}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 592.964172, DeltaTheta: 0.175338}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.593
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.938/PNear + 0.062/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.938] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.938,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.938,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.062] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.062,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.062,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.40117e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.938,Zero),AlgebraicProduct(0.062,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.027277
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.341/VSlowLeft + 0.240/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.938,VSlowLeft),AlgebraicProduct(0.062,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: -0.000000, rot-vel: 1.562858}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 592.347168, DeltaTheta: -0.014237}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.592
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 593.178162, DeltaTheta: -0.135187}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.593
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.815/NNear + 0.185/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.815] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.815,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.815,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.185] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.185,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.185,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.1307
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.148/Backwards + 0.000/MediumBackwards + 0.443/Zero + 0.557/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.815,Zero),AlgebraicProduct(0.185,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0179295
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.605/SlowRight + 0.815/VSlowRight + 0.185/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.815,VSlowRight),AlgebraicProduct(0.185,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 11.130680, rot-vel: -1.027283}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 591.824097, DeltaTheta: -0.256008}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.592
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.252/NFar + 0.748/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.252] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.252,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.252,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.748] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.748,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.748,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.91053e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.252,Zero),AlgebraicProduct(0.748,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0246541
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.707/SlowRight + 0.879/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.252,SlowRight),AlgebraicProduct(0.748,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: -0.000000, rot-vel: -1.412575}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 589.627014, DeltaTheta: -0.154077}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.590
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.012/NFar + 0.988/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.012] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.012,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.988] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.988,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.11097e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.012,Zero),AlgebraicProduct(0.988,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0218225
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.664/SlowRight + 0.992/VSlowRight + 0.008/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.012,SlowRight),AlgebraicProduct(0.988,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: -0.000000, rot-vel: -1.250337}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 586.627014, DeltaTheta: -0.066978}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.587
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 584.270874, DeltaTheta: -0.041532}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.584
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 582.030701, DeltaTheta: -0.029258}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.582
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 578.232056, DeltaTheta: 0.051773}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.578
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:06]: {Distance: 570.348938, DeltaTheta: 0.029570}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.570
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:06]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 563.081299, DeltaTheta: -0.041867}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.563
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 553.931946, DeltaTheta: -0.068573}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.554
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 551.093018, DeltaTheta: -0.079634}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.551
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.069/NNear + 0.931/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.069] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.069,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.069,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.931] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.931,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.931,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 55.8645
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.207/Forward + 0.793/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.069,Zero),AlgebraicProduct(0.931,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00137165
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.354/SlowRight + 0.062/VSlowRight + 0.938/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.069,VSlowRight),AlgebraicProduct(0.931,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 55.864464, rot-vel: -0.078590}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 547.862793, DeltaTheta: -0.123393}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.548
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.657/NNear + 0.343/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.657] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.657,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.657,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.343] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.343,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.343,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.6458
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.968/MediumForward + 0.032/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.657,Zero),AlgebraicProduct(0.343,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0144552
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.552/SlowRight + 0.657/VSlowRight + 0.343/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.657,VSlowRight),AlgebraicProduct(0.343,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 20.645821, rot-vel: -0.828220}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 544.803040, DeltaTheta: -0.102380}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.545
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.375/NNear + 0.625/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.375] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.375,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.375,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.625] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.625,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.625,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 37.5743
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.121/MediumForward + 0.879/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.375,Zero),AlgebraicProduct(0.625,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00800836
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.455/SlowRight + 0.364/VSlowRight + 0.636/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.375,VSlowRight),AlgebraicProduct(0.625,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 37.574322, rot-vel: -0.458845}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 541.026733, DeltaTheta: -0.006240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.541
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 539.377197, DeltaTheta: 0.083516}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.539
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.879/Zero + 0.121/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.121] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.879] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.745
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.363/Forward + 0.637/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,Zero),AlgebraicProduct(0.879,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00142597
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.312/SlowRight + 0.000/VSlowRight + 0.935/Zero + 0.018/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,VSlowLeft),AlgebraicProduct(0.879,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 52.744981, rot-vel: 0.081702}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 534.509399, DeltaTheta: 0.090915}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.535
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.779/Zero + 0.221/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.221] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.779] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.779,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.779,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.7973
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.660/Forward + 0.340/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.221,Zero),AlgebraicProduct(0.779,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00278259
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.291/SlowRight + 0.000/VSlowRight + 0.874/Zero + 0.035/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.221,VSlowLeft),AlgebraicProduct(0.779,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 46.797250, rot-vel: 0.159431}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 528.749329, DeltaTheta: 0.105912}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.529
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.578/Zero + 0.422/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.422] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.578] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 34.7306
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.263/MediumForward + 0.737/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.422,Zero),AlgebraicProduct(0.578,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00619177
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.240/SlowRight + 0.000/VSlowRight + 0.719/Zero + 0.077/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.422,VSlowLeft),AlgebraicProduct(0.578,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 34.730570, rot-vel: 0.354762}
[ DORIS] [2018-03-14 16:30:07]: {Distance: 523.012573, DeltaTheta: 0.109084}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.523
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.535/Zero + 0.465/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.465] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.465,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.535] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.535,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 32.1764
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.391/MediumForward + 0.609/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,Zero),AlgebraicProduct(0.535,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00705092
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.227/SlowRight + 0.000/VSlowRight + 0.680/Zero + 0.088/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.465,VSlowLeft),AlgebraicProduct(0.535,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:07]: {lin-vel: 32.176443, rot-vel: 0.403988}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 517.913574, DeltaTheta: 0.198252}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.518
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.884/PNear + 0.116/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.884] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.884,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.884,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.116] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.116,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.116,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.24405e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.884,Zero),AlgebraicProduct(0.116,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0290649
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.363/VSlowLeft + 0.321/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.884,VSlowLeft),AlgebraicProduct(0.116,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: -0.000000, rot-vel: 1.665295}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 512.505493, DeltaTheta: 0.161066}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.513
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.971/PNear + 0.029/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.971] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.029] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.11901e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,Zero),AlgebraicProduct(0.029,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0260753
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.326/VSlowLeft + 0.185/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,VSlowLeft),AlgebraicProduct(0.029,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: -0.000000, rot-vel: 1.494006}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 508.555328, DeltaTheta: 0.151732}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.509
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.993/PNear + 0.007/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.993] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.007] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.15071e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.993,Zero),AlgebraicProduct(0.007,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0252503
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.316/VSlowLeft + 0.148/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.993,VSlowLeft),AlgebraicProduct(0.007,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: -0.000000, rot-vel: 1.446737}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 508.701904, DeltaTheta: 0.121457}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.509
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.369/Zero + 0.631/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.631] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.631,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.369] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.369,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 22.2067
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.890/MediumForward + 0.110/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.631,Zero),AlgebraicProduct(0.369,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0109971
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.167/SlowRight + 0.000/VSlowRight + 0.500/Zero + 0.137/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.631,VSlowLeft),AlgebraicProduct(0.369,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 22.206684, rot-vel: 0.630085}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 509.506287, DeltaTheta: -0.097004}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.510
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.302/NNear + 0.698/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.302] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.302,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.302,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.698] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.698,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.698,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 41.8999
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.905/Forward + 0.095/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.302,Zero),AlgebraicProduct(0.698,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00637709
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.430/SlowRight + 0.290/VSlowRight + 0.710/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.302,VSlowRight),AlgebraicProduct(0.698,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 41.899894, rot-vel: -0.365380}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 508.336395, DeltaTheta: -0.073430}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.508
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 504.829712, DeltaTheta: -0.045386}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.505
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 500.213165, DeltaTheta: -0.133496}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.500
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.792/NNear + 0.208/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.792] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.792,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.792,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.208] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.208,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.208,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 12.4955
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.125/Backwards + 0.000/MediumBackwards + 0.375/Zero + 0.625/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.792,Zero),AlgebraicProduct(0.208,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0174443
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.598/SlowRight + 0.793/VSlowRight + 0.207/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.792,VSlowRight),AlgebraicProduct(0.208,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 12.495489, rot-vel: -0.999483}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 493.678497, DeltaTheta: -0.101632}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.494
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.364/NNear + 0.636/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.364] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.636] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 38.1758
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.091/MediumForward + 0.909/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.364,Zero),AlgebraicProduct(0.636,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00778014
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.451/SlowRight + 0.354/VSlowRight + 0.646/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.364,VSlowRight),AlgebraicProduct(0.636,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 38.175844, rot-vel: -0.445769}
[ DORIS] [2018-03-14 16:30:08]: {Distance: 488.045654, DeltaTheta: -0.091186}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.488
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.224/NNear + 0.776/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.224] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.224,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.224,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.776] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.776,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.776,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.5799
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.671/Forward + 0.329/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.224,Zero),AlgebraicProduct(0.776,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00464655
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.404/SlowRight + 0.211/VSlowRight + 0.789/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.224,VSlowRight),AlgebraicProduct(0.776,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:08]: {lin-vel: 46.579925, rot-vel: -0.266228}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 483.951752, DeltaTheta: 0.014171}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.484
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 478.212860, DeltaTheta: 0.077005}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.478
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.966/Zero + 0.034/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.034] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.034,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.034,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.966] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.966,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.966,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 57.9763
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.101/Forward + 0.899/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.034,Zero),AlgebraicProduct(0.966,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000374869
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.328/SlowRight + 0.000/VSlowRight + 0.983/Zero + 0.005/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.034,VSlowLeft),AlgebraicProduct(0.966,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 57.976320, rot-vel: 0.021478}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 477.749329, DeltaTheta: -0.048015}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.478
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 474.975494, DeltaTheta: 0.083972}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.475
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.873/Zero + 0.127/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.127] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.127,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.127,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.873] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.873,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.873,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.3787
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.381/Forward + 0.619/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.127,Zero),AlgebraicProduct(0.873,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00150429
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.311/SlowRight + 0.000/VSlowRight + 0.932/Zero + 0.019/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.127,VSlowLeft),AlgebraicProduct(0.873,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 52.378732, rot-vel: 0.086190}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 468.129517, DeltaTheta: 0.110794}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.468
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.513/Zero + 0.487/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.487] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.513] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 30.7991
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.460/MediumForward + 0.540/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.487,Zero),AlgebraicProduct(0.513,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0075376
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.219/SlowRight + 0.000/VSlowRight + 0.657/Zero + 0.094/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.487,VSlowLeft),AlgebraicProduct(0.513,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 30.799060, rot-vel: 0.431873}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 461.677032, DeltaTheta: 0.134894}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.462
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.189/Zero + 0.811/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.811] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.811,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.811,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.189] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.189,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.189,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.3677
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.144/Backwards + 0.000/MediumBackwards + 0.432/Zero + 0.568/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.811,Zero),AlgebraicProduct(0.189,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0166885
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.080/SlowRight + 0.000/VSlowRight + 0.241/Zero + 0.209/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.811,VSlowLeft),AlgebraicProduct(0.189,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 11.367718, rot-vel: 0.956179}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 457.021271, DeltaTheta: 0.121830}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.457
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.364/Zero + 0.636/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.636] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.636,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.364] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.364,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.9056
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.905/MediumForward + 0.095/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.636,Zero),AlgebraicProduct(0.364,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0111331
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.165/SlowRight + 0.000/VSlowRight + 0.494/Zero + 0.139/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.636,VSlowLeft),AlgebraicProduct(0.364,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 21.905616, rot-vel: 0.637879}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 454.228333, DeltaTheta: 0.061640}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.454
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 453.703857, DeltaTheta: -0.051635}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.454
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:09]: {Distance: 453.703857, DeltaTheta: -0.051635}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.454
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:09]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 448.950989, DeltaTheta: -0.021758}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.449
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 442.309174, DeltaTheta: 0.123305}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.442
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.345/Zero + 0.655/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.655] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.655,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.655,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.345] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.345,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.345,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.717
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.964/MediumForward + 0.036/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.655,Zero),AlgebraicProduct(0.345,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0116811
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.156/SlowRight + 0.000/VSlowRight + 0.469/Zero + 0.146/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.655,VSlowLeft),AlgebraicProduct(0.345,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 20.716977, rot-vel: 0.669280}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 434.231812, DeltaTheta: 0.082446}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.434
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.893/Zero + 0.107/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.107] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.107,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.107,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.893] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.893,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.893,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 53.6051
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.320/Forward + 0.680/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.107,Zero),AlgebraicProduct(0.893,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00124457
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.314/SlowRight + 0.000/VSlowRight + 0.943/Zero + 0.016/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.107,VSlowLeft),AlgebraicProduct(0.893,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 53.605072, rot-vel: 0.071309}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 427.165802, DeltaTheta: 0.101083}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.427
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.643/Zero + 0.357/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.357] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.643] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.643,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.643,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 38.6182
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.069/MediumForward + 0.931/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.357,Zero),AlgebraicProduct(0.643,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00498376
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.258/SlowRight + 0.000/VSlowRight + 0.773/Zero + 0.062/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.357,VSlowLeft),AlgebraicProduct(0.643,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 38.618237, rot-vel: 0.285548}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 425.965271, DeltaTheta: -0.029194}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.426
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 421.957672, DeltaTheta: 0.117557}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.422
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.422/Zero + 0.578/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.578] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.578,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.422] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.422,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 25.3507
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.732/MediumForward + 0.268/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.578,Zero),AlgebraicProduct(0.422,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00964008
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.187/SlowRight + 0.000/VSlowRight + 0.562/Zero + 0.121/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.578,VSlowLeft),AlgebraicProduct(0.422,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 25.350651, rot-vel: 0.552336}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 419.377380, DeltaTheta: 0.161427}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.419
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.971/PNear + 0.029/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.971] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.971,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.029] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.029,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.0745e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,Zero),AlgebraicProduct(0.029,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0261066
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.326/VSlowLeft + 0.187/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.971,VSlowLeft),AlgebraicProduct(0.029,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: -0.000000, rot-vel: 1.495797}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 415.226898, DeltaTheta: 0.002004}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.415
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 412.460938, DeltaTheta: -0.112664}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.412
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.513/NNear + 0.487/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.513] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.487] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 29.2927
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.535/MediumForward + 0.465/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.513,Zero),AlgebraicProduct(0.487,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0111726
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.503/SlowRight + 0.508/VSlowRight + 0.492/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.513,VSlowRight),AlgebraicProduct(0.487,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: 29.292717, rot-vel: -0.640146}
[ DORIS] [2018-03-14 16:30:10]: {Distance: 409.298645, DeltaTheta: -0.201536}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.409
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.124/NFar + 0.876/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.124] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.124,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.124,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.876] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.876,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.876,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.69339e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.124,Zero),AlgebraicProduct(0.876,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0232167
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.685/SlowRight + 0.945/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.124,SlowRight),AlgebraicProduct(0.876,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:10]: {lin-vel: -0.000000, rot-vel: -1.330221}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 405.475098, DeltaTheta: -0.239590}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.405
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.214/NFar + 0.786/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.214] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.214,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.214,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.786] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.786,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.786,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.88204e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.214,Zero),AlgebraicProduct(0.786,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0242423
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.701/SlowRight + 0.898/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.214,SlowRight),AlgebraicProduct(0.786,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: -1.388980}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 401.281525, DeltaTheta: 0.169108}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.401
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.953/PNear + 0.047/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.953] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.047] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.65767e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,Zero),AlgebraicProduct(0.047,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0267612
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.335/VSlowLeft + 0.216/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,VSlowLeft),AlgebraicProduct(0.047,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: 1.533301}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 397.018524, DeltaTheta: 0.184385}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.397
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.916/PNear + 0.084/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.916] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.916,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.916,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.084] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.084,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.084,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.18964e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.916,Zero),AlgebraicProduct(0.084,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0280031
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.350/VSlowLeft + 0.273/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.916,VSlowLeft),AlgebraicProduct(0.084,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: 1.604457}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 394.391418, DeltaTheta: 0.211535}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.394
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.852/PNear + 0.148/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.852] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.852,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.148] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.148,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.24197e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.852,Zero),AlgebraicProduct(0.148,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0300269
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.375/VSlowLeft + 0.365/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.852,VSlowLeft),AlgebraicProduct(0.148,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: 1.720414}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 393.277832, DeltaTheta: 0.153179}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.393
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.990/PNear + 0.010/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.990] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.990,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.010] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.010,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.04523e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.990,Zero),AlgebraicProduct(0.010,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0253803
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.317/VSlowLeft + 0.154/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.990,VSlowLeft),AlgebraicProduct(0.010,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: 1.454186}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 393.206268, DeltaTheta: 0.096801}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.393
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.700/Zero + 0.300/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.300] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.300,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.300,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.700] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.700,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.700,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 42.0638
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.897/Forward + 0.103/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.300,Zero),AlgebraicProduct(0.700,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00400419
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.273/SlowRight + 0.000/VSlowRight + 0.818/Zero + 0.050/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.300,VSlowLeft),AlgebraicProduct(0.700,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: 42.063844, rot-vel: 0.229423}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 392.568115, DeltaTheta: -0.055183}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.393
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 393.539307, DeltaTheta: -0.145281}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.394
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.950/NNear + 0.050/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.950] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.050] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.9797
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.284/Backwards + 0.000/MediumBackwards + 0.851/Zero + 0.149/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.950,Zero),AlgebraicProduct(0.050,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0207085
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.647/SlowRight + 0.941/VSlowRight + 0.059/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.950,VSlowRight),AlgebraicProduct(0.050,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: 2.979695, rot-vel: -1.186508}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 391.371704, DeltaTheta: -0.201985}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.391
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.125/NFar + 0.875/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.125] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.125,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.125,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.875] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.875,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.875,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.33208e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.125,Zero),AlgebraicProduct(0.875,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0232294
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.685/SlowRight + 0.944/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.125,SlowRight),AlgebraicProduct(0.875,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: -0.000000, rot-vel: -1.330945}
[ DORIS] [2018-03-14 16:30:11]: {Distance: 387.745148, DeltaTheta: -0.138448}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.388
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.859/NNear + 0.141/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.859] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.859,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.859,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.141] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.141,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.141,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 8.49841
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.192/Backwards + 0.000/MediumBackwards + 0.575/Zero + 0.425/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.859,Zero),AlgebraicProduct(0.141,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0188502
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.619/SlowRight + 0.857/VSlowRight + 0.143/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.859,VSlowRight),AlgebraicProduct(0.141,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:11]: {lin-vel: 8.498412, rot-vel: -1.080037}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 385.069489, DeltaTheta: 0.069220}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.385
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 380.908875, DeltaTheta: 0.145877}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.381
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.042/Zero + 0.958/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.958] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.958,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.958,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.042] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.042,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.042,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.49808
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.292/Backwards + 0.000/MediumBackwards + 0.875/Zero + 0.125/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.958,Zero),AlgebraicProduct(0.042,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0229086
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.286/VSlowLeft + 0.041/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.958,VSlowLeft),AlgebraicProduct(0.042,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 2.498075, rot-vel: 1.312566}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 378.323425, DeltaTheta: 0.238703}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.378
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.788/PNear + 0.212/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.788] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.788,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.788,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.212] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.212,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.212,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.32133e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.788,Zero),AlgebraicProduct(0.212,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0318388
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.398/VSlowLeft + 0.447/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.788,VSlowLeft),AlgebraicProduct(0.212,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: -0.000000, rot-vel: 1.824232}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 373.476501, DeltaTheta: 0.154646}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.373
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.987/PNear + 0.013/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.987] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.013] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.39342e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,Zero),AlgebraicProduct(0.013,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0255113
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.319/VSlowLeft + 0.160/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,VSlowLeft),AlgebraicProduct(0.013,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: -0.000000, rot-vel: 1.461692}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 370.886993, DeltaTheta: 0.080865}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.371
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.914/Zero + 0.086/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.086] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.086,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.086,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.914] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.914,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.914,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 54.875
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.256/Forward + 0.744/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.086,Zero),AlgebraicProduct(0.914,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000983072
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.318/SlowRight + 0.000/VSlowRight + 0.955/Zero + 0.012/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.086,VSlowLeft),AlgebraicProduct(0.914,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 54.875019, rot-vel: 0.056326}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 370.974091, DeltaTheta: -0.161758}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.371
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.030/NFar + 0.970/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.030] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.970] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.80776e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.030,Zero),AlgebraicProduct(0.970,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0220551
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.668/SlowRight + 0.997/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.030,SlowRight),AlgebraicProduct(0.970,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: -0.000000, rot-vel: -1.263662}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 369.887360, DeltaTheta: -0.133943}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.370
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.798/NNear + 0.202/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.798] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.202] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 12.1347
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.131/Backwards + 0.000/MediumBackwards + 0.393/Zero + 0.607/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,Zero),AlgebraicProduct(0.202,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.017573
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.600/SlowRight + 0.799/VSlowRight + 0.201/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,VSlowRight),AlgebraicProduct(0.202,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 12.134741, rot-vel: -1.006860}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 368.347443, DeltaTheta: 0.001143}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.368
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 368.168427, DeltaTheta: 0.143621}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.368
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.072/Zero + 0.928/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.928] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.928,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.928,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.072] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.072,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.072,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.32089
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.261/Backwards + 0.000/MediumBackwards + 0.784/Zero + 0.216/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.928,Zero),AlgebraicProduct(0.072,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0214861
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.008/SlowRight + 0.000/VSlowRight + 0.023/Zero + 0.269/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.928,VSlowLeft),AlgebraicProduct(0.072,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: 4.320895, rot-vel: 1.231064}
[ DORIS] [2018-03-14 16:30:12]: {Distance: 367.326660, DeltaTheta: 0.179858}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.367
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.927/PNear + 0.073/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.927] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.927,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.927,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.073] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.073,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.073,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.19286e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.927,Zero),AlgebraicProduct(0.073,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0276431
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.346/VSlowLeft + 0.257/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.927,VSlowLeft),AlgebraicProduct(0.073,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:12]: {lin-vel: -0.000000, rot-vel: 1.583833}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 364.276642, DeltaTheta: 0.228254}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.364
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.813/PNear + 0.187/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.813] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.187] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.44204e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.813,Zero),AlgebraicProduct(0.187,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0311657
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.390/VSlowLeft + 0.417/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.813,VSlowLeft),AlgebraicProduct(0.187,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: -0.000000, rot-vel: 1.785661}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 363.011414, DeltaTheta: 0.147171}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.363
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.024/Zero + 0.976/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.976] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.976,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.024] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.45285
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.309/Backwards + 0.000/MediumBackwards + 0.927/Zero + 0.073/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.976,Zero),AlgebraicProduct(0.024,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0237628
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.297/VSlowLeft + 0.080/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.976,VSlowLeft),AlgebraicProduct(0.024,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 1.452853, rot-vel: 1.361511}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 361.524353, DeltaTheta: 0.006542}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.362
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 361.750244, DeltaTheta: -0.147482}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.362
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.980/NNear + 0.020/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.980] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.980,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.980,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.020] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.020,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.020,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.20174
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.313/Backwards + 0.000/MediumBackwards + 0.940/Zero + 0.060/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.980,Zero),AlgebraicProduct(0.020,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0212842
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.656/SlowRight + 0.967/VSlowRight + 0.033/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.980,VSlowRight),AlgebraicProduct(0.020,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 1.201743, rot-vel: -1.219497}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 361.252258, DeltaTheta: -0.390385}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.361
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.569/NFar + 0.431/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.569] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.569,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.569,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.431] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.431,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.431,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.60656e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.569,Zero),AlgebraicProduct(0.431,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0272547
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.746/SlowRight + 0.761/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.569,SlowRight),AlgebraicProduct(0.431,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: -0.000000, rot-vel: -1.561581}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 356.640930, DeltaTheta: -0.354818}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.357
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.486/NFar + 0.514/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.486] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.486,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.514] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.514,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.40741e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.486,Zero),AlgebraicProduct(0.514,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0266998
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.738/SlowRight + 0.786/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.486,SlowRight),AlgebraicProduct(0.514,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: -0.000000, rot-vel: -1.529784}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 351.963074, DeltaTheta: -0.119803}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.352
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.608/NNear + 0.392/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.608] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.608,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.608,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.392] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.392,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.392,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.5404
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.823/MediumForward + 0.177/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.608,Zero),AlgebraicProduct(0.392,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0133647
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.536/SlowRight + 0.607/VSlowRight + 0.393/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.608,VSlowRight),AlgebraicProduct(0.392,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 23.540381, rot-vel: -0.765740}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 349.978912, DeltaTheta: 0.076741}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.350
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.970/Zero + 0.030/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.030] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.030,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.970] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.970,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 58.1879
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.091/Forward + 0.909/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.030,Zero),AlgebraicProduct(0.970,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000334881
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.328/SlowRight + 0.000/VSlowRight + 0.985/Zero + 0.004/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.030,VSlowLeft),AlgebraicProduct(0.970,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 58.187923, rot-vel: 0.019187}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 347.120239, DeltaTheta: 0.150830}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.347
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.996/PNear + 0.004/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.78665e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.996,Zero),AlgebraicProduct(0.004,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0251689
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.315/VSlowLeft + 0.144/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.996,VSlowLeft),AlgebraicProduct(0.004,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: -0.000000, rot-vel: 1.442073}
[ DORIS] [2018-03-14 16:30:13]: {Distance: 344.649841, DeltaTheta: 0.051789}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.345
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:13]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 338.967377, DeltaTheta: 0.031783}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.339
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 337.815887, DeltaTheta: -0.122683}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.338
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.647/NNear + 0.353/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.647] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.647,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.647,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.353] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.353,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.353,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 21.218
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.939/MediumForward + 0.061/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.647,Zero),AlgebraicProduct(0.353,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0142406
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.549/SlowRight + 0.647/VSlowRight + 0.353/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.647,VSlowRight),AlgebraicProduct(0.353,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 21.217967, rot-vel: -0.815923}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 335.412903, DeltaTheta: -0.293806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.335
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.342/NFar + 0.658/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.342] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.342,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.658] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.658,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.10971e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.342,Zero),AlgebraicProduct(0.658,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0255256
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.720/SlowRight + 0.840/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.342,SlowRight),AlgebraicProduct(0.658,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: -0.000000, rot-vel: -1.462512}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 332.539917, DeltaTheta: -0.281941}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.333
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.314/NFar + 0.686/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.314] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.314,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.314,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.686] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.686,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.686,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.87253e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.314,Zero),AlgebraicProduct(0.686,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0252638
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.716/SlowRight + 0.852/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.314,SlowRight),AlgebraicProduct(0.686,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 0.000000, rot-vel: -1.447510}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 331.726501, DeltaTheta: -0.225378}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.332
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.180/NFar + 0.820/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.180] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.820] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.20583e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,Zero),AlgebraicProduct(0.820,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0238704
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.695/SlowRight + 0.915/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.180,SlowRight),AlgebraicProduct(0.820,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: -0.000000, rot-vel: -1.367674}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 332.501007, DeltaTheta: -0.091108}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.333
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.223/NNear + 0.777/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.223] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.223,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.223,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.777] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.777,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.777,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.6426
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.668/Forward + 0.332/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.223,Zero),AlgebraicProduct(0.777,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00462369
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.403/SlowRight + 0.210/VSlowRight + 0.790/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.223,VSlowRight),AlgebraicProduct(0.777,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 46.642574, rot-vel: -0.264918}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 333.567474, DeltaTheta: -0.099385}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.334
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.334/NNear + 0.666/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.334] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.666] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 39.9841
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.999/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.334,Zero),AlgebraicProduct(0.666,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00709653
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.441/SlowRight + 0.323/VSlowRight + 0.677/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.334,VSlowRight),AlgebraicProduct(0.666,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 39.984093, rot-vel: -0.406601}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 330.196411, DeltaTheta: -0.044876}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.330
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 325.876007, DeltaTheta: -0.143787}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.326
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.930/NNear + 0.070/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.930] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.070] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 4.18705
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.264/Backwards + 0.000/MediumBackwards + 0.791/Zero + 0.209/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,Zero),AlgebraicProduct(0.070,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0203109
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.641/SlowRight + 0.923/VSlowRight + 0.077/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,VSlowRight),AlgebraicProduct(0.070,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 4.187049, rot-vel: -1.163727}
[ DORIS] [2018-03-14 16:30:14]: {Distance: 322.143494, DeltaTheta: -0.145142}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.322
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.949/NNear + 0.051/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.949] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.051] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 3.09253
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.282/Backwards + 0.000/MediumBackwards + 0.845/Zero + 0.155/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.949,Zero),AlgebraicProduct(0.051,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0206715
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.647/SlowRight + 0.940/VSlowRight + 0.060/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.949,VSlowRight),AlgebraicProduct(0.051,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:14]: {lin-vel: 3.092528, rot-vel: -1.184391}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 318.301300, DeltaTheta: -0.170224}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.318
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.050/NFar + 0.950/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.050] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.950] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.14247e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.050,Zero),AlgebraicProduct(0.950,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0223087
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.671/SlowRight + 0.986/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.050,SlowRight),AlgebraicProduct(0.950,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: 0.000000, rot-vel: -1.278193}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 317.298462, DeltaTheta: 0.080464}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.317
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.920/Zero + 0.080/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.080] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.080,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.080,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.920] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.920,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.920,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 55.1976
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.240/Forward + 0.760/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.080,Zero),AlgebraicProduct(0.920,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.000917831
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.319/SlowRight + 0.000/VSlowRight + 0.958/Zero + 0.011/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.080,VSlowLeft),AlgebraicProduct(0.920,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: 55.197589, rot-vel: 0.052588}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 315.359741, DeltaTheta: 0.169000}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.315
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.953/PNear + 0.047/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.953] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.047] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.12628e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,Zero),AlgebraicProduct(0.047,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0267521
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.334/VSlowLeft + 0.216/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,VSlowLeft),AlgebraicProduct(0.047,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: 1.532783}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 316.476105, DeltaTheta: 0.242985}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.316
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.778/PNear + 0.222/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.778] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.778,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.222] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.222,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.61578e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.778,Zero),AlgebraicProduct(0.222,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0321065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.401/VSlowLeft + 0.459/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.778,VSlowLeft),AlgebraicProduct(0.222,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: 1.839568}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 316.625641, DeltaTheta: 0.120297}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.317
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.385/Zero + 0.615/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.615] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.615,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.615,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.385] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.385,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.385,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 23.1416
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.843/MediumForward + 0.157/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.615,Zero),AlgebraicProduct(0.385,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0105816
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.173/SlowRight + 0.000/VSlowRight + 0.519/Zero + 0.132/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.615,VSlowLeft),AlgebraicProduct(0.385,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: 23.141571, rot-vel: 0.606281}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 315.063232, DeltaTheta: 0.185172}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.315
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.915/PNear + 0.085/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.915] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.915,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.915,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.085] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.085,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.085,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.3786e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.915,Zero),AlgebraicProduct(0.085,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0280649
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.351/VSlowLeft + 0.276/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.915,VSlowLeft),AlgebraicProduct(0.085,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: 1.608002}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 310.192017, DeltaTheta: -0.005599}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.310
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 307.363831, DeltaTheta: -0.179036}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.307
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.071/NFar + 0.929/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.071] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.929] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.73948e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.071,Zero),AlgebraicProduct(0.929,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0225693
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.675/SlowRight + 0.974/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.071,SlowRight),AlgebraicProduct(0.929,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: -1.293124}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 306.380524, DeltaTheta: -0.262574}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.306
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.268/NFar + 0.732/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.268] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.268,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.268,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.732] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.732,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.732,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.32769e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.268,Zero),AlgebraicProduct(0.732,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0248133
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.709/SlowRight + 0.872/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.268,SlowRight),AlgebraicProduct(0.732,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: -1.421695}
[ DORIS] [2018-03-14 16:30:15]: {Distance: 304.923828, DeltaTheta: -0.316723}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.305
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.396/NFar + 0.604/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.396] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.604] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.75443e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,Zero),AlgebraicProduct(0.604,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0260004
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.727/SlowRight + 0.818/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,SlowRight),AlgebraicProduct(0.604,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:15]: {lin-vel: -0.000000, rot-vel: -1.489714}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 303.274109, DeltaTheta: -0.297265}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.303
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.350/NFar + 0.650/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.350] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.350,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.350,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.650] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.650,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.650,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.26082e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.350,Zero),AlgebraicProduct(0.650,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0255999
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.721/SlowRight + 0.836/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.350,SlowRight),AlgebraicProduct(0.650,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: -1.466767}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 300.544922, DeltaTheta: -0.279005}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.301
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.307/NFar + 0.693/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.307] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.307,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.307,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.693] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.693,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.693,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.05645e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.307,Zero),AlgebraicProduct(0.693,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0251974
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.715/SlowRight + 0.855/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.307,SlowRight),AlgebraicProduct(0.693,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: -1.443703}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 302.078064, DeltaTheta: -0.232633}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.302
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.197/NFar + 0.803/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.197] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.803] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.7586e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.197,Zero),AlgebraicProduct(0.803,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.024062
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.698/SlowRight + 0.906/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.197,SlowRight),AlgebraicProduct(0.803,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: -1.378649}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 301.662720, DeltaTheta: -0.125167}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.302
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.680/NNear + 0.320/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.680] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.320] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 19.2151
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.013/Backwards + 0.000/MediumBackwards + 0.039/Zero + 0.961/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.680,Zero),AlgebraicProduct(0.320,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0149895
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.560/SlowRight + 0.681/VSlowRight + 0.319/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.680,VSlowRight),AlgebraicProduct(0.320,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: 19.215082, rot-vel: -0.858838}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 304.078186, DeltaTheta: -0.149036}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.304
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 1.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.000] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.000,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.03441e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.000,Zero),AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0216687
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.985/VSlowRight + 0.015/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.000,SlowRight),AlgebraicProduct(1.000,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: -1.241526}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 305.244965, DeltaTheta: 0.013997}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.305
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 305.169250, DeltaTheta: 0.148276}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.305
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.009/Zero + 0.991/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.991] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.991,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.991,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.009] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.009,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.009,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 0.559994
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.324/Backwards + 0.000/MediumBackwards + 0.972/Zero + 0.028/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.991,Zero),AlgebraicProduct(0.009,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0245161
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.306/VSlowLeft + 0.114/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.991,VSlowLeft),AlgebraicProduct(0.009,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: 0.559994, rot-vel: 1.404669}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 304.757477, DeltaTheta: 0.345892}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.305
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.536/PNear + 0.464/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.536] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.536,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.536,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.464] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.464,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.464,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.57446e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.536,Zero),AlgebraicProduct(0.464,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0373148
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.466/VSlowLeft + 0.696/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.536,VSlowLeft),AlgebraicProduct(0.464,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: 2.137980}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 303.295837, DeltaTheta: 0.431753}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.303
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.333/PNear + 0.667/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.333] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.667] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.41535e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.333,Zero),AlgebraicProduct(0.667,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0402667
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.503/VSlowLeft + 0.830/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.333,VSlowLeft),AlgebraicProduct(0.667,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: 2.307114}
[ DORIS] [2018-03-14 16:30:16]: {Distance: 302.295868, DeltaTheta: 0.433181}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.302
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.330/PNear + 0.670/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.330] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.330,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.330,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.670] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.670,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.670,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.63619e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.330,Zero),AlgebraicProduct(0.670,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0403076
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.504/VSlowLeft + 0.832/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.330,VSlowLeft),AlgebraicProduct(0.670,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:16]: {lin-vel: -0.000000, rot-vel: 2.309456}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 301.703735, DeltaTheta: 0.154674}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.302
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.987/PNear + 0.013/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.987] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.987,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.013] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.013,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.4906e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,Zero),AlgebraicProduct(0.013,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0255138
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.319/VSlowLeft + 0.160/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.987,VSlowLeft),AlgebraicProduct(0.013,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: 0.000000, rot-vel: 1.461834}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 300.661987, DeltaTheta: -0.150616}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.301
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.004/NFar + 0.996/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.02488e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,Zero),AlgebraicProduct(0.996,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.021717
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.662/SlowRight + 0.987/VSlowRight + 0.013/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,SlowRight),AlgebraicProduct(0.996,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: -1.244293}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 300.661987, DeltaTheta: -0.238278}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.301
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.211/NFar + 0.789/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.211] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.211,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.211,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.789] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.789,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.789,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.14516e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.211,Zero),AlgebraicProduct(0.789,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0242085
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.700/SlowRight + 0.900/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.211,SlowRight),AlgebraicProduct(0.789,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: -1.387047}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 299.761993, DeltaTheta: -0.336647}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.300
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.443/NFar + 0.557/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.443] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.443,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.443,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.557] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.557,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.557,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.88334e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.443,Zero),AlgebraicProduct(0.557,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.02638
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.733/SlowRight + 0.801/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.443,SlowRight),AlgebraicProduct(0.557,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: -1.511465}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 299.584137, DeltaTheta: -0.213443}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.300
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.152/NFar + 0.848/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.152] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.152,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.848] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.848,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.12653e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.152,Zero),AlgebraicProduct(0.848,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0235477
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.690/SlowRight + 0.930/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.152,SlowRight),AlgebraicProduct(0.848,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: -1.349182}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 296.981018, DeltaTheta: -0.071074}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.297
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 294.549591, DeltaTheta: 0.240737}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.295
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.784/PNear + 0.216/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.784] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.216] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.36258e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.784,Zero),AlgebraicProduct(0.216,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0319666
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.400/VSlowLeft + 0.453/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.784,VSlowLeft),AlgebraicProduct(0.216,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: 1.831549}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 292.988495, DeltaTheta: 0.333073}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.293
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.566/PNear + 0.434/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.566] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.434] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.70079e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.566,Zero),AlgebraicProduct(0.434,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0367786
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.460/VSlowLeft + 0.672/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.566,VSlowLeft),AlgebraicProduct(0.434,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: 2.107257}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 289.117188, DeltaTheta: 0.355341}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.289
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.513/PNear + 0.487/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.513] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.513,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.487] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.487,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.55725e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.513,Zero),AlgebraicProduct(0.487,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0376925
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.471/VSlowLeft + 0.713/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.513,VSlowLeft),AlgebraicProduct(0.487,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: -0.000000, rot-vel: 2.159621}
[ DORIS] [2018-03-14 16:30:17]: {Distance: 288.875458, DeltaTheta: -0.004025}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.289
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:17]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 289.331940, DeltaTheta: -0.489313}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.289
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.803/NFar + 0.197/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.803] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.803,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.197] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.197,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.09573e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.803,Zero),AlgebraicProduct(0.197,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.028358
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.763/SlowRight + 0.711/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.803,SlowRight),AlgebraicProduct(0.197,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: -0.000000, rot-vel: -1.624795}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 289.331940, DeltaTheta: -0.576976}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.289
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.007/NVeryFar + 0.993/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.007] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.007,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.993] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.993,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.74293e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.007,Zero),AlgebraicProduct(0.993,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0290026
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.773/SlowRight + 0.682/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.007,FastRight),AlgebraicProduct(0.993,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: -0.000000, rot-vel: -1.661727}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 287.186432, DeltaTheta: -0.411454}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.287
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.619/NFar + 0.381/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.619] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.619,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.619,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.381] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.381,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.381,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.52808e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.619,Zero),AlgebraicProduct(0.381,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0275413
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.751/SlowRight + 0.748/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.619,SlowRight),AlgebraicProduct(0.381,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: -0.000000, rot-vel: -1.578000}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 285.772247, DeltaTheta: -0.237731}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.286
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.209/NFar + 0.791/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.209] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.209,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.791] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.791,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.88633e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,Zero),AlgebraicProduct(0.791,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0241944
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.700/SlowRight + 0.900/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.209,SlowRight),AlgebraicProduct(0.791,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 0.000000, rot-vel: -1.386238}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 285.660156, DeltaTheta: -0.026440}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.286
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 286.295593, DeltaTheta: 0.070647}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.286
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 285.096039, DeltaTheta: 0.186576}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.285
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.911/PNear + 0.089/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.911] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.911,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.911,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.089] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.089,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.089,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.8496e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.911,Zero),AlgebraicProduct(0.089,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0281749
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.352/VSlowLeft + 0.281/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.911,VSlowLeft),AlgebraicProduct(0.089,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: -0.000000, rot-vel: 1.614303}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 280.403076, DeltaTheta: 0.173370}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.280
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.942/PNear + 0.058/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.942] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.942,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.942,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.058] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.058,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.058,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.56652e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.942,Zero),AlgebraicProduct(0.058,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0271155
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.339/VSlowLeft + 0.233/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.942,VSlowLeft),AlgebraicProduct(0.058,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 0.000000, rot-vel: 1.553601}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 276.163269, DeltaTheta: 0.039422}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.276
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:18]: {Distance: 273.000977, DeltaTheta: -0.048291}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.273
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:18]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 272.203735, DeltaTheta: -0.508202}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.272
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.847/NFar + 0.153/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.847] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.847,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.153] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.153,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.28721e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.847,Zero),AlgebraicProduct(0.153,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0285055
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.765/SlowRight + 0.704/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.847,SlowRight),AlgebraicProduct(0.153,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: -0.000000, rot-vel: -1.633247}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 270.898956, DeltaTheta: -0.522946}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.271
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.882/NFar + 0.118/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.882] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.118] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.64296e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,Zero),AlgebraicProduct(0.118,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0286087
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.767/SlowRight + 0.700/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,SlowRight),AlgebraicProduct(0.118,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: 0.000000, rot-vel: -1.639158}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 269.376740, DeltaTheta: -0.145893}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.269
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.959/NNear + 0.041/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.959] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.959,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.959,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.041] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.041,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.041,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.48575
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.292/Backwards + 0.000/MediumBackwards + 0.876/Zero + 0.124/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.959,Zero),AlgebraicProduct(0.041,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0208696
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.650/SlowRight + 0.949/VSlowRight + 0.051/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.959,VSlowRight),AlgebraicProduct(0.041,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: 2.485748, rot-vel: -1.195740}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 268.123871, DeltaTheta: 0.017127}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.268
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 261.321564, DeltaTheta: 0.203519}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.261
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.871/PNear + 0.129/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.871] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.871,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.871,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.129] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.129,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.129,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.40102e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.871,Zero),AlgebraicProduct(0.129,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0294526
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.368/VSlowLeft + 0.339/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.871,VSlowLeft),AlgebraicProduct(0.129,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: -0.000000, rot-vel: 1.687508}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 257.789001, DeltaTheta: 0.433493}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.258
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.329/PNear + 0.671/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.329] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.329,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.329,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.671] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.671,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.671,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.80222e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.329,Zero),AlgebraicProduct(0.671,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0403165
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.504/VSlowLeft + 0.833/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.329,VSlowLeft),AlgebraicProduct(0.671,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: 0.000000, rot-vel: 2.309965}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 254.338791, DeltaTheta: 0.480661}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.254
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.218/PNear + 0.782/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.218] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.218,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.218,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.782] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.782,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.782,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.77143e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.218,Zero),AlgebraicProduct(0.782,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0415381
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.519/VSlowLeft + 0.888/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.218,VSlowLeft),AlgebraicProduct(0.782,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: -0.000000, rot-vel: 2.379958}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 251.796997, DeltaTheta: 0.429034}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.252
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.339/PNear + 0.661/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.339] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.339,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.339,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.661] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.661,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.661,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.10062e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.339,Zero),AlgebraicProduct(0.661,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0401883
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.502/VSlowLeft + 0.827/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.339,VSlowLeft),AlgebraicProduct(0.661,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: -0.000000, rot-vel: 2.302619}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 248.737839, DeltaTheta: 0.270821}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.249
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.713/PNear + 0.287/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.713] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.713,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.713,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.287] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.07024e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.713,Zero),AlgebraicProduct(0.287,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.033737
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.422/VSlowLeft + 0.533/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.713,VSlowLeft),AlgebraicProduct(0.287,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: -0.000000, rot-vel: 1.932987}
[ DORIS] [2018-03-14 16:30:19]: {Distance: 249.187927, DeltaTheta: 0.004126}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.249
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:19]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 249.149582, DeltaTheta: -0.028149}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.249
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 250.788925, DeltaTheta: -0.057274}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.251
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 249.486237, DeltaTheta: -0.041304}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.249
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 245.426041, DeltaTheta: -0.101268}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.245
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.360/NNear + 0.640/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.360] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.360,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.640] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.640,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 38.4693
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.077/MediumForward + 0.923/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.360,Zero),AlgebraicProduct(0.640,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00766894
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.450/SlowRight + 0.349/VSlowRight + 0.651/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.360,VSlowRight),AlgebraicProduct(0.640,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 38.469284, rot-vel: -0.439398}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 237.916351, DeltaTheta: -0.106848}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.238
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.434/NNear + 0.566/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.434] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.566] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 33.9773
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.301/MediumForward + 0.699/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.434,Zero),AlgebraicProduct(0.566,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00937946
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.475/SlowRight + 0.426/VSlowRight + 0.574/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.434,VSlowRight),AlgebraicProduct(0.566,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 33.977307, rot-vel: -0.537404}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 230.414734, DeltaTheta: -0.248847}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.230
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.236/NFar + 0.764/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.236] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.236,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.236,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.764] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.764,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.764,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.82447e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.236,Zero),AlgebraicProduct(0.764,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0244769
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.704/SlowRight + 0.887/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.236,SlowRight),AlgebraicProduct(0.764,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: -0.000000, rot-vel: -1.402421}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 225.344193, DeltaTheta: -0.317072}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.225
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.396/NFar + 0.604/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.396] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.396,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.604] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.604,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.25447e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,Zero),AlgebraicProduct(0.604,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0260073
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.727/SlowRight + 0.818/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.396,SlowRight),AlgebraicProduct(0.604,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: -0.000000, rot-vel: -1.490110}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 224.095642, DeltaTheta: 0.029560}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.224
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 223.417877, DeltaTheta: 0.098414}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.223
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.679/Zero + 0.321/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.321] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.321,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.679] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.679,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.7657
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.962/Forward + 0.038/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.321,Zero),AlgebraicProduct(0.679,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00436379
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.267/SlowRight + 0.000/VSlowRight + 0.802/Zero + 0.055/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.321,VSlowLeft),AlgebraicProduct(0.679,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: 40.765667, rot-vel: 0.250027}
[ DORIS] [2018-03-14 16:30:20]: {Distance: 223.364197, DeltaTheta: 0.157902}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.223
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.979/PNear + 0.021/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.979] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.979,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.021] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.57847e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,Zero),AlgebraicProduct(0.021,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0257992
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.322/VSlowLeft + 0.173/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.979,VSlowLeft),AlgebraicProduct(0.021,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:20]: {lin-vel: -0.000000, rot-vel: 1.478187}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 221.195923, DeltaTheta: 0.485783}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.221
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.206/PNear + 0.794/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.206] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.206,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.794] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.794,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.39796e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,Zero),AlgebraicProduct(0.794,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.041657
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.521/VSlowLeft + 0.893/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.206,VSlowLeft),AlgebraicProduct(0.794,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 2.386769}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 216.171753, DeltaTheta: 0.503224}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.216
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.164/PNear + 0.836/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.164] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.164,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.164,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.836] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.836,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.836,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.05401e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.164,Zero),AlgebraicProduct(0.836,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0420433
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.526/VSlowLeft + 0.911/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.164,VSlowLeft),AlgebraicProduct(0.836,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 2.408902}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 214.474670, DeltaTheta: 0.289319}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.214
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.669/PNear + 0.331/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.669] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.669,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.331] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.1801e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.669,Zero),AlgebraicProduct(0.331,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0347226
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.434/VSlowLeft + 0.578/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.669,VSlowLeft),AlgebraicProduct(0.331,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 1.989457}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 213.205139, DeltaTheta: -0.265650}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.213
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.275/NFar + 0.725/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.275] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.275,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.275,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.725] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.725,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.725,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.7669e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.275,Zero),AlgebraicProduct(0.725,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0248867
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.710/SlowRight + 0.869/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.275,SlowRight),AlgebraicProduct(0.725,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: -1.425905}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 214.284439, DeltaTheta: -0.343508}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.214
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.459/NFar + 0.541/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.459] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.541] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.33292e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.459,Zero),AlgebraicProduct(0.541,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0265037
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.735/SlowRight + 0.795/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.459,SlowRight),AlgebraicProduct(0.541,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: -1.518551}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 215.015106, DeltaTheta: -0.434651}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.215
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.674/NFar + 0.326/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.674] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.674,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.326] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.326,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.05545e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.674,Zero),AlgebraicProduct(0.326,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0278228
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.755/SlowRight + 0.735/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.674,SlowRight),AlgebraicProduct(0.326,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: -1.594127}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 215.287827, DeltaTheta: -0.098328}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.215
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.320/NNear + 0.680/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.320] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.320,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.680] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.680,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.8346
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.958/Forward + 0.042/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.320,Zero),AlgebraicProduct(0.680,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00677646
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.436/SlowRight + 0.308/VSlowRight + 0.692/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.320,VSlowRight),AlgebraicProduct(0.680,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: 40.834625, rot-vel: -0.388263}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 212.971710, DeltaTheta: 0.150953}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.213
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.995/PNear + 0.005/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.995] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.995,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.005] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.22831e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.995,Zero),AlgebraicProduct(0.005,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0251801
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.315/VSlowLeft + 0.145/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.995,VSlowLeft),AlgebraicProduct(0.005,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 1.442713}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 211.497330, DeltaTheta: 0.342908}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.211
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.543/PNear + 0.457/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.543] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.543,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.543,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.457] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.457,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.457,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.11313e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.543,Zero),AlgebraicProduct(0.457,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0371924
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.465/VSlowLeft + 0.691/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.543,VSlowLeft),AlgebraicProduct(0.457,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 2.130969}
[ DORIS] [2018-03-14 16:30:21]: {Distance: 208.860306, DeltaTheta: 0.344603}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.539/PNear + 0.461/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.539] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.539,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.539,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.461] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.461,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.461,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.27644e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.539,Zero),AlgebraicProduct(0.461,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0372621
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.466/VSlowLeft + 0.694/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.539,VSlowLeft),AlgebraicProduct(0.461,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:21]: {lin-vel: -0.000000, rot-vel: 2.134962}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 208.945145, DeltaTheta: 0.290217}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.209
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.667/PNear + 0.333/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.667] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.667,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.333] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.333,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.4094e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,Zero),AlgebraicProduct(0.333,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0347686
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.435/VSlowLeft + 0.580/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.667,VSlowLeft),AlgebraicProduct(0.333,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: 1.992093}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 210.505463, DeltaTheta: -0.129504}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.211
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.739/NNear + 0.261/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.739] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.739,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.739,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.261] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.261,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.261,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 15.7172
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.071/Backwards + 0.000/MediumBackwards + 0.214/Zero + 0.786/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.739,Zero),AlgebraicProduct(0.261,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0162799
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.580/SlowRight + 0.740/VSlowRight + 0.260/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.739,VSlowRight),AlgebraicProduct(0.261,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: 15.717163, rot-vel: -0.932772}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 212.934875, DeltaTheta: -0.335338}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.213
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.440/NFar + 0.560/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.440] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.440,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.440,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.560] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.560,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.560,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.59273e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.440,Zero),AlgebraicProduct(0.560,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.026356
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.733/SlowRight + 0.802/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.440,SlowRight),AlgebraicProduct(0.560,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: -1.510090}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 215.583176, DeltaTheta: -0.604441}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.216
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.055/NVeryFar + 0.945/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.055] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.055,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.055,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.945] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.945,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.945,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 6.96257e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.055,Zero),AlgebraicProduct(0.945,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.029811
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.785/SlowRight + 0.645/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.055,FastRight),AlgebraicProduct(0.945,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: 0.000000, rot-vel: -1.708046}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 216.073883, DeltaTheta: -0.346679}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.216
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.466/NFar + 0.534/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.466] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.466,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.466,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.534] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.534,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.534,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.38307e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.466,Zero),AlgebraicProduct(0.534,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0265597
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.736/SlowRight + 0.793/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.466,SlowRight),AlgebraicProduct(0.534,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: -1.521756}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 213.813400, DeltaTheta: -0.130178}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.214
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.748/NNear + 0.252/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.748] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.748,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.748,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.252] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.252,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.252,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 15.1735
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.080/Backwards + 0.000/MediumBackwards + 0.241/Zero + 0.759/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.748,Zero),AlgebraicProduct(0.252,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0164782
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.583/SlowRight + 0.749/VSlowRight + 0.251/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.748,VSlowRight),AlgebraicProduct(0.252,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: 15.173487, rot-vel: -0.944130}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 212.712418, DeltaTheta: 0.292281}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.213
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.662/PNear + 0.338/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.662] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.662,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.662,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.338] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.338,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.338,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.08546e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.662,Zero),AlgebraicProduct(0.338,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0348736
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.436/VSlowLeft + 0.585/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.662,VSlowLeft),AlgebraicProduct(0.338,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: 1.998110}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 210.121140, DeltaTheta: 0.374100}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.469/PNear + 0.531/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.469] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.531] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.14597e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,Zero),AlgebraicProduct(0.531,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0384007
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.480/VSlowLeft + 0.745/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,VSlowLeft),AlgebraicProduct(0.531,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: 2.200196}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 210.121140, DeltaTheta: 0.374100}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.469/PNear + 0.531/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.469] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.531] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.14597e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,Zero),AlgebraicProduct(0.531,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0384007
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.480/VSlowLeft + 0.745/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,VSlowLeft),AlgebraicProduct(0.531,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: 2.200196}
[ DORIS] [2018-03-14 16:30:22]: {Distance: 210.121140, DeltaTheta: 0.374100}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.469/PNear + 0.531/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.469] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.469,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.531] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.531,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.14597e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,Zero),AlgebraicProduct(0.531,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0384007
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.480/VSlowLeft + 0.745/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.469,VSlowLeft),AlgebraicProduct(0.531,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:22]: {lin-vel: -0.000000, rot-vel: 2.200196}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 210.188629, DeltaTheta: 0.044473}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 209.525345, DeltaTheta: -0.017610}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.210
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 207.858536, DeltaTheta: -0.071160}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.208
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 205.351059, DeltaTheta: -0.017758}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.205
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 60
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.000/Forward + 1.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 3.1978e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 60.000000, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 202.365372, DeltaTheta: -0.200051}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.202
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.120/NFar + 0.880/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.120] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.120,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.880] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.880,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.05297e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,Zero),AlgebraicProduct(0.880,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0231749
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.947/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.120,SlowRight),AlgebraicProduct(0.880,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: -0.000000, rot-vel: -1.327821}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 197.355469, DeltaTheta: -0.417952}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.197
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.026/PFar + 0.974/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.634/NFar + 0.366/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.634] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.634,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.634,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.366] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.366,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.366,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.1777e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.634,Zero),AlgebraicProduct(0.366,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0276237
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.752/SlowRight + 0.744/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.634,SlowRight),AlgebraicProduct(0.366,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: -0.000000, rot-vel: -1.582719}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 193.554031, DeltaTheta: -0.475533}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.194
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.064/PFar + 0.936/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.770/NFar + 0.230/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.770] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.770,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.770,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.230] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.230,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.230,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.11593e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.770,Zero),AlgebraicProduct(0.230,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0282389
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.761/SlowRight + 0.716/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.770,SlowRight),AlgebraicProduct(0.230,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: -0.000000, rot-vel: -1.617968}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 191.635895, DeltaTheta: -0.383080}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.192
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.084/PFar + 0.916/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.552/NFar + 0.448/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.552] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.448] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.448,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.448,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 1.14676e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.552,Zero),AlgebraicProduct(0.448,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0271482
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.745/SlowRight + 0.766/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.552,SlowRight),AlgebraicProduct(0.448,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 0.000000, rot-vel: -1.555477}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 193.274780, DeltaTheta: 0.122517}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.193
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.067/PFar + 0.933/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.355/Zero + 0.645/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.645] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.645,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.645,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.024] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.024,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.331] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.331,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 20.8337
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.958/MediumForward + 0.042/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.645,Zero),AlgebraicProduct(0.024,Forward),AlgebraicProduct(0.331,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0114634
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.160/SlowRight + 0.000/VSlowRight + 0.479/Zero + 0.143/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.645,VSlowLeft),AlgebraicProduct(0.024,Zero),AlgebraicProduct(0.331,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: 20.833682, rot-vel: 0.656805}
[ DORIS] [2018-03-14 16:30:23]: {Distance: 192.627502, DeltaTheta: 0.545153}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.193
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.074/PFar + 0.926/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.066/PNear + 0.934/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.066] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.934] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.16914e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.066,Zero),AlgebraicProduct(0.934,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0428642
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.536/VSlowLeft + 0.948/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.066,VSlowLeft),AlgebraicProduct(0.934,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:23]: {lin-vel: -0.000000, rot-vel: 2.455935}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 189.194397, DeltaTheta: 1.023444}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.189
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.108/PFar + 0.892/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.018
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.214/PFar + 0.786/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.214] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.214,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.214,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.786] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.786,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.786,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.99627e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.214,Zero),AlgebraicProduct(0.786,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0606955
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.241/SlowLeft + 0.759/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.214,SlowLeft),AlgebraicProduct(0.786,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: 3.477595}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 188.194550, DeltaTheta: 0.940986}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.188
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.118/PFar + 0.882/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.016
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.358/PFar + 0.642/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.358] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.358,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.358,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.642] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.642,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.642,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.06267e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.358,Zero),AlgebraicProduct(0.642,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0575666
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.383/SlowLeft + 0.617/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.358,SlowLeft),AlgebraicProduct(0.642,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: 3.298321}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 186.294022, DeltaTheta: 0.428281}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.186
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.137/PFar + 0.863/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.341/PNear + 0.659/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.341] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.341,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.659] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.659,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.21878e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,Zero),AlgebraicProduct(0.659,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0401664
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.502/VSlowLeft + 0.826/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.341,VSlowLeft),AlgebraicProduct(0.659,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: 2.301365}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 184.879822, DeltaTheta: 0.167564}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.185
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.151/PFar + 0.849/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.956/PNear + 0.044/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.956] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.956,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.956,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.044] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.044,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.044,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.20512e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.956,Zero),AlgebraicProduct(0.044,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0266312
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.333/VSlowLeft + 0.211/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.956,VSlowLeft),AlgebraicProduct(0.044,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: 1.525855}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 184.742111, DeltaTheta: -0.200068}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.185
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.153/PFar + 0.847/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.121/NFar + 0.879/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.121] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.121,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.879] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.879,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.01145e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,Zero),AlgebraicProduct(0.879,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0231753
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.684/SlowRight + 0.947/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.121,SlowRight),AlgebraicProduct(0.879,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: -1.327850}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 184.897110, DeltaTheta: -0.334145}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.185
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.151/PFar + 0.849/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.437/NFar + 0.563/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.437] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.437,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.563] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.563,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.04198e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,Zero),AlgebraicProduct(0.563,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0263341
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.732/SlowRight + 0.803/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.437,SlowRight),AlgebraicProduct(0.563,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: -1.508830}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 187.762314, DeltaTheta: -0.477560}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.188
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.122/PFar + 0.878/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.775/NFar + 0.225/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.775] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.775,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.775,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.225] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.225,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.225,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.61728e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.775,Zero),AlgebraicProduct(0.225,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.028257
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.761/SlowRight + 0.716/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.775,SlowRight),AlgebraicProduct(0.225,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: -1.619009}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 188.043991, DeltaTheta: -0.339127}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.188
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.120/PFar + 0.880/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.448/NFar + 0.552/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.448] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.448,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.448,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.552] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.38592e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.448,Zero),AlgebraicProduct(0.552,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0264252
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.734/SlowRight + 0.799/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.448,SlowRight),AlgebraicProduct(0.552,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: -0.000000, rot-vel: -1.514050}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 188.354889, DeltaTheta: -0.135569}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.188
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.116/PFar + 0.884/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.820/NNear + 0.180/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.820] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.820,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.021] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.021,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.159] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.159,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.159,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 10.3786
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.160/Backwards + 0.000/MediumBackwards + 0.481/Zero + 0.519/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.820,Zero),AlgebraicProduct(0.021,Forward),AlgebraicProduct(0.159,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0180694
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.607/SlowRight + 0.821/VSlowRight + 0.179/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.820,VSlowRight),AlgebraicProduct(0.021,Zero),AlgebraicProduct(0.159,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: 10.378582, rot-vel: -1.035301}
[ DORIS] [2018-03-14 16:30:24]: {Distance: 187.354889, DeltaTheta: 0.039500}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.187
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.126/PFar + 0.874/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.126] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.126,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.126,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.874] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.874,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.874,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 57.6188
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.119/Forward + 0.881/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.126,Forward),AlgebraicProduct(0.874,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 4.80741e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.126,Zero),AlgebraicProduct(0.874,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:24]: {lin-vel: 57.618792, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 186.358231, DeltaTheta: 0.312549}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.186
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.136/PFar + 0.864/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.614/PNear + 0.386/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.614] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.614,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.614,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.386] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.386,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.386,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.53438e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.614,Zero),AlgebraicProduct(0.386,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0358596
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.448/VSlowLeft + 0.630/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.614,VSlowLeft),AlgebraicProduct(0.386,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: 2.054603}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 186.297928, DeltaTheta: 0.677746}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.186
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.137/PFar + 0.863/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.817/PFar + 0.183/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.817] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.817,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.817,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.183] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.183,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.183,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.16626e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.817,Zero),AlgebraicProduct(0.183,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0472204
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.854/SlowLeft + 0.146/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.817,SlowLeft),AlgebraicProduct(0.183,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: 2.705530}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 183.298141, DeltaTheta: 0.688838}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.183
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.167/PFar + 0.833/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.798/PFar + 0.202/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.798] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.798,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.202] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.202,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.31337e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,Zero),AlgebraicProduct(0.202,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0476464
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.834/SlowLeft + 0.166/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.798,SlowLeft),AlgebraicProduct(0.202,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: 2.729935}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 180.136017, DeltaTheta: 0.435634}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.199/PFar + 0.801/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.324/PNear + 0.676/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.324] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.676] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.39195e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,Zero),AlgebraicProduct(0.676,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0403773
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.505/VSlowLeft + 0.835/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.324,VSlowLeft),AlgebraicProduct(0.676,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: 2.313446}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 180.495499, DeltaTheta: -0.411847}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.195/PFar + 0.805/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.620/NFar + 0.380/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.620] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.620,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.620,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.380] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.380,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.380,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.50554e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.620,Zero),AlgebraicProduct(0.380,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0275464
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.751/SlowRight + 0.748/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.620,SlowRight),AlgebraicProduct(0.380,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: -1.578290}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 182.317505, DeltaTheta: -0.710338}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.182
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.177/PFar + 0.823/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.240/NVeryFar + 0.760/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.240] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.240,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.240,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.760] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.760,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.760,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.68951e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.240,Zero),AlgebraicProduct(0.760,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0334971
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.841/SlowRight + 0.477/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.240,FastRight),AlgebraicProduct(0.760,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: -1.919245}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 184.012894, DeltaTheta: -0.863422}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.184
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.160/PFar + 0.840/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.015
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.507/NVeryFar + 0.493/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.507] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.507,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.507,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.493] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.493,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.493,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.95801e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.507,Zero),AlgebraicProduct(0.493,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0408724
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.953/SlowRight + 0.142/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.507,FastRight),AlgebraicProduct(0.493,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: -2.341816}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 183.956116, DeltaTheta: 0.027952}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.184
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.160/PFar + 0.840/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.160] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.160,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.160,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.840] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.840,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.840,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.9567
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.152/Forward + 0.848/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.160,Forward),AlgebraicProduct(0.840,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.28789e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.160,Zero),AlgebraicProduct(0.840,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: 56.956665, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 182.956116, DeltaTheta: 0.028105}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.183
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.170/PFar + 0.830/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.170] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.170,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.830] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.830,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 56.7603
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.162/Forward + 0.838/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,Forward),AlgebraicProduct(0.830,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 4.38502e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.170,Zero),AlgebraicProduct(0.830,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: 56.760273, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:25]: {Distance: 181.967667, DeltaTheta: 0.345060}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.182
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.180/PFar + 0.820/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.538/PNear + 0.462/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.538] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.538,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.538,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.462] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.462,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.462,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.55685e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.538,Zero),AlgebraicProduct(0.462,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0372808
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.466/VSlowLeft + 0.695/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.538,VSlowLeft),AlgebraicProduct(0.462,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:25]: {lin-vel: -0.000000, rot-vel: 2.136034}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 178.679794, DeltaTheta: 0.633381}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.213/PFar + 0.787/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.895/PFar + 0.105/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.895] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.895,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.895,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.105] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.105,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.105,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.26776e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.895,Zero),AlgebraicProduct(0.105,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0455418
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.930/SlowLeft + 0.070/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.895,SlowLeft),AlgebraicProduct(0.105,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: 2.609353}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 173.940674, DeltaTheta: 0.613255}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.261/PFar + 0.739/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.930/PFar + 0.070/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.930] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.930,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.070] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.070,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.43909e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,Zero),AlgebraicProduct(0.070,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0447953
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.964/SlowLeft + 0.036/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.930,SlowLeft),AlgebraicProduct(0.070,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: 2.566582}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 172.665466, DeltaTheta: 0.332351}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.173
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.273/PFar + 0.727/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.567/PNear + 0.433/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.567] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.567,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.567,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.433] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.433,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.433,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.66694e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.567,Zero),AlgebraicProduct(0.433,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0367475
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.459/VSlowLeft + 0.670/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.567,VSlowLeft),AlgebraicProduct(0.433,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: 2.105477}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 174.022018, DeltaTheta: -0.257774}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.260/PFar + 0.740/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.257/NFar + 0.743/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.257] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.257,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.257,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.743] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.743,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.743,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 5.38079e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.257,Zero),AlgebraicProduct(0.743,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0246972
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.708/SlowRight + 0.877/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.257,SlowRight),AlgebraicProduct(0.743,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: 0.000000, rot-vel: -1.415047}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 178.382187, DeltaTheta: -0.544884}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.178
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.216/PFar + 0.784/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.934/NFar + 0.066/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.934] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.934,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.066] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.066,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.88479e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.934,Zero),AlgebraicProduct(0.066,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0287442
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.769/SlowRight + 0.693/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.934,SlowRight),AlgebraicProduct(0.066,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: -1.646922}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 179.326233, DeltaTheta: -0.602350}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.207/PFar + 0.793/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.051/NVeryFar + 0.949/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.051] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.051,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.949] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.949,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.34372e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.051,Zero),AlgebraicProduct(0.949,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0297475
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.784/SlowRight + 0.648/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.051,FastRight),AlgebraicProduct(0.949,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: -1.704409}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 179.547867, DeltaTheta: -0.351805}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.205/PFar + 0.795/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.478/NFar + 0.522/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.478] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.478,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.478,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.522] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.522,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.522,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.71207e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.478,Zero),AlgebraicProduct(0.522,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0266485
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.737/SlowRight + 0.789/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.478,SlowRight),AlgebraicProduct(0.522,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: -1.526846}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 179.547867, DeltaTheta: -0.264143}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.205/PFar + 0.795/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.272/NFar + 0.728/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.272] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.272,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.272,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.728] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.728,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.728,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.42559e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.272,Zero),AlgebraicProduct(0.728,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0248508
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.710/SlowRight + 0.870/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.272,SlowRight),AlgebraicProduct(0.728,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: 0.000000, rot-vel: -1.423847}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 179.813599, DeltaTheta: 0.115621}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.180
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.202/PFar + 0.798/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.448/Zero + 0.552/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.552] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.552,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.090] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.357] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.357,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 24.961
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.752/MediumForward + 0.248/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.552,Zero),AlgebraicProduct(0.090,Forward),AlgebraicProduct(0.357,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00924588
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.193/SlowRight + 0.000/VSlowRight + 0.580/Zero + 0.116/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.552,VSlowLeft),AlgebraicProduct(0.090,Zero),AlgebraicProduct(0.357,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: 24.960991, rot-vel: 0.529750}
[ DORIS] [2018-03-14 16:30:26]: {Distance: 178.711838, DeltaTheta: 0.343736}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.213/PFar + 0.787/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.541/PNear + 0.459/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.541] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.459] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.18189e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.541,Zero),AlgebraicProduct(0.459,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0372265
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.465/VSlowLeft + 0.692/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.541,VSlowLeft),AlgebraicProduct(0.459,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:26]: {lin-vel: -0.000000, rot-vel: 2.132924}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 178.711838, DeltaTheta: 0.343736}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.179
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.213/PFar + 0.787/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.541/PNear + 0.459/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.541] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.541,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.459] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.459,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.18189e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.541,Zero),AlgebraicProduct(0.459,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0372265
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.465/VSlowLeft + 0.692/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.541,VSlowLeft),AlgebraicProduct(0.459,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: 2.132924}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 176.991486, DeltaTheta: 0.498336}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.177
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.230/PFar + 0.770/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.176/PNear + 0.824/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.176] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.176,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.176,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.824] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.824,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.824,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.61615e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.176,Zero),AlgebraicProduct(0.824,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0419378
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.524/VSlowLeft + 0.906/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.176,VSlowLeft),AlgebraicProduct(0.824,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: 2.402861}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 176.346771, DeltaTheta: 0.436029}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.176
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.237/PFar + 0.763/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.323/PNear + 0.677/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.323] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.323,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.323,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.677] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.677,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.677,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.03118e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.323,Zero),AlgebraicProduct(0.677,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0403884
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.505/VSlowLeft + 0.836/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.323,VSlowLeft),AlgebraicProduct(0.677,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: 2.314083}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 175.346786, DeltaTheta: 0.262690}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.175
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.247/PFar + 0.753/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.732/PNear + 0.268/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.732] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.732,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.732,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.268] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.268,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.268,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.57995e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.732,Zero),AlgebraicProduct(0.268,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0332797
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.416/VSlowLeft + 0.513/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.732,VSlowLeft),AlgebraicProduct(0.268,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: 1.906787}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 174.454956, DeltaTheta: 0.131903}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.255/PFar + 0.745/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.229/Zero + 0.771/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.771] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.771,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.771,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.059] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.059,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.059,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.171] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.171,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.171,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 12.5407
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.124/Backwards + 0.000/MediumBackwards + 0.373/Zero + 0.627/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.771,Zero),AlgebraicProduct(0.059,Forward),AlgebraicProduct(0.171,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0154094
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.100/SlowRight + 0.000/VSlowRight + 0.300/Zero + 0.193/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.771,VSlowLeft),AlgebraicProduct(0.059,Zero),AlgebraicProduct(0.171,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: 12.540727, rot-vel: 0.882896}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 174.454956, DeltaTheta: 0.044240}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.255/PFar + 0.745/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.255] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.745] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 55.0648
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.247/Forward + 0.753/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.255,Forward),AlgebraicProduct(0.745,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.64495e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.255,Zero),AlgebraicProduct(0.745,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: 55.064842, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 173.579102, DeltaTheta: -0.107505}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.174
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.264/PFar + 0.736/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.443/NNear + 0.557/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.443] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.443,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.443,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.147] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.147,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.147,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.410] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.410,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.410,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 30.3009
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.485/MediumForward + 0.515/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.443,Zero),AlgebraicProduct(0.147,Forward),AlgebraicProduct(0.410,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00992766
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.484/SlowRight + 0.451/VSlowRight + 0.549/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.443,VSlowRight),AlgebraicProduct(0.147,Zero),AlgebraicProduct(0.410,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: 30.300922, rot-vel: -0.568813}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 170.818100, DeltaTheta: -0.183423}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.171
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.292/PFar + 0.708/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.081/NFar + 0.919/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.081] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.081,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.081,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.919] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.919,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.919,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.92881e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.081,Zero),AlgebraicProduct(0.919,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0226976
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.677/SlowRight + 0.968/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.081,SlowRight),AlgebraicProduct(0.919,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: -1.300477}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 166.281601, DeltaTheta: -0.176229}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.166
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.337/PFar + 0.663/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.064/NFar + 0.936/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.064] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.064,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.936] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.936,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.52456e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,Zero),AlgebraicProduct(0.936,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0224866
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.674/SlowRight + 0.978/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.064,SlowRight),AlgebraicProduct(0.936,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: -1.288390}
[ DORIS] [2018-03-14 16:30:27]: {Distance: 163.352570, DeltaTheta: -0.290594}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.163
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.366/PFar + 0.634/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.334/NFar + 0.666/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.334] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.334,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.666] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.666,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.53502e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.334,Zero),AlgebraicProduct(0.666,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0254559
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.719/SlowRight + 0.843/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.334,SlowRight),AlgebraicProduct(0.666,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:27]: {lin-vel: -0.000000, rot-vel: -1.458513}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 161.561905, DeltaTheta: 0.005464}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.162
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.384/PFar + 0.616/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.384] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.384,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.616] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.616,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 52.4249
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.379/Forward + 0.621/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,Forward),AlgebraicProduct(0.616,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.86306e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.384,Zero),AlgebraicProduct(0.616,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: 52.424854, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 161.163177, DeltaTheta: 0.204806}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.161
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.388/PFar + 0.612/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.868/PNear + 0.132/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.868] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.868,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.868,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.132] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.132,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.132,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.20074e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.868,Zero),AlgebraicProduct(0.132,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0295461
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.369/VSlowLeft + 0.343/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.868,VSlowLeft),AlgebraicProduct(0.132,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: 0.000000, rot-vel: 1.692866}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 160.940994, DeltaTheta: 0.455025}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.161
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.391/PFar + 0.609/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.278/PNear + 0.722/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.278] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.278,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.278,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.722] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.722,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.722,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.13423e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.278,Zero),AlgebraicProduct(0.722,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0409037
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.511/VSlowLeft + 0.859/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.278,VSlowLeft),AlgebraicProduct(0.722,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: -0.000000, rot-vel: 2.343609}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 160.940994, DeltaTheta: 0.542688}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.161
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.391/PFar + 0.609/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.071/PNear + 0.929/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.071] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.071,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.929] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.929,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.15757e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.071,Zero),AlgebraicProduct(0.929,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0428198
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.535/VSlowLeft + 0.946/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.071,VSlowLeft),AlgebraicProduct(0.929,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: -0.000000, rot-vel: 2.453394}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 158.123901, DeltaTheta: 0.655451}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.158
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.419/PFar + 0.581/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.856/PFar + 0.144/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.856] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.856,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.856,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.144] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.144,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.144,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.27487e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.856,Zero),AlgebraicProduct(0.144,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0463716
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.892/SlowLeft + 0.108/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.856,SlowLeft),AlgebraicProduct(0.144,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: -0.000000, rot-vel: 2.656894}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 157.269333, DeltaTheta: 0.493609}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.157
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.427/PFar + 0.573/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.187/PNear + 0.813/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.187] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.187,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.813] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.813,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.73315e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.187,Zero),AlgebraicProduct(0.813,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0418338
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.523/VSlowLeft + 0.902/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.187,VSlowLeft),AlgebraicProduct(0.813,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: 0.000000, rot-vel: 2.396898}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 156.269363, DeltaTheta: 0.320881}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.156
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.437/PFar + 0.563/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.595/PNear + 0.405/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.595] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.595,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.595,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.405] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.405,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.405,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.14671e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.595,Zero),AlgebraicProduct(0.405,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.036242
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.453/VSlowLeft + 0.647/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.595,VSlowLeft),AlgebraicProduct(0.405,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: -0.000000, rot-vel: 2.076511}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 156.426224, DeltaTheta: 0.198805}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.156
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.436/PFar + 0.564/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.882/PNear + 0.118/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.882] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.882,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.118] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.118,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.95348e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,Zero),AlgebraicProduct(0.118,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0291059
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.364/VSlowLeft + 0.323/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.882,VSlowLeft),AlgebraicProduct(0.118,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: 0.000000, rot-vel: 1.667648}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 156.426224, DeltaTheta: 0.111142}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.156
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.436/PFar + 0.564/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.508/Zero + 0.492/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.492] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.492,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.492,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.221] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.221,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.287] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.287,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 25.8216
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.709/MediumForward + 0.291/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.492,Zero),AlgebraicProduct(0.221,Forward),AlgebraicProduct(0.287,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00802845
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.212/SlowRight + 0.000/VSlowRight + 0.635/Zero + 0.100/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.492,VSlowLeft),AlgebraicProduct(0.221,Zero),AlgebraicProduct(0.287,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: 25.821567, rot-vel: 0.459996}
[ DORIS] [2018-03-14 16:30:28]: {Distance: 155.897354, DeltaTheta: 0.155961}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.156
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.441/PFar + 0.559/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.984/PNear + 0.016/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.984] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.984,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.016] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.016,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.24499e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,Zero),AlgebraicProduct(0.016,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.025628
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.320/VSlowLeft + 0.165/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.984,VSlowLeft),AlgebraicProduct(0.016,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:28]: {lin-vel: -0.000000, rot-vel: 1.468379}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 154.766846, DeltaTheta: 0.081449}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.155
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.452/PFar + 0.548/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.906/Zero + 0.094/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.094] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.094,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.094,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.410] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.410,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.410,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.496] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.496,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.496,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.0797
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.696/Forward + 0.304/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.094,Zero),AlgebraicProduct(0.410,Forward),AlgebraicProduct(0.496,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.00122942
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.315/SlowRight + 0.000/VSlowRight + 0.944/Zero + 0.015/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.094,VSlowLeft),AlgebraicProduct(0.410,Zero),AlgebraicProduct(0.496,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 46.079742, rot-vel: 0.070441}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 153.409988, DeltaTheta: -0.042946}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.153
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.466/PFar + 0.534/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.466] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.466,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.466,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.534] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.534,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.534,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 50.7301
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.463/Forward + 0.537/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.466,Forward),AlgebraicProduct(0.534,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 6.23164e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.466,Zero),AlgebraicProduct(0.534,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 50.730138, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 151.995773, DeltaTheta: -0.043345}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.152
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.480/PFar + 0.520/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.480] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.480,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.480,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.520] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.520,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.520,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 50.4352
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.478/Forward + 0.522/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.480,Forward),AlgebraicProduct(0.520,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 6.19915e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.480,Zero),AlgebraicProduct(0.520,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 50.435196, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 148.832855, DeltaTheta: 0.122783}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.149
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.512/PFar + 0.488/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.352/Zero + 0.648/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.648] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.648,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.648,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.180] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.180,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.172] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.172,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.172,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 17.3519
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.044/Backwards + 0.000/MediumBackwards + 0.132/Zero + 0.868/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.648,Zero),AlgebraicProduct(0.180,Forward),AlgebraicProduct(0.172,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0117964
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.155/SlowRight + 0.000/VSlowRight + 0.464/Zero + 0.147/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.648,VSlowLeft),AlgebraicProduct(0.180,Zero),AlgebraicProduct(0.172,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 17.351885, rot-vel: 0.675881}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 145.080444, DeltaTheta: 0.222871}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.145
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.549/PFar + 0.451/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.826/PNear + 0.174/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.826] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.826,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.826,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.174] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.174,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.174,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.01345e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.826,Zero),AlgebraicProduct(0.174,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0308075
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.385/VSlowLeft + 0.400/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.826,VSlowLeft),AlgebraicProduct(0.174,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: -0.000000, rot-vel: 1.765139}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 139.268829, DeltaTheta: 0.606143}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.139
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.607/PFar + 0.393/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.011
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.942/PFar + 0.058/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.942] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.942,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.942,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.058] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.058,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.058,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.67947e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.942,Zero),AlgebraicProduct(0.058,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.044534
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.976/SlowLeft + 0.024/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.942,SlowLeft),AlgebraicProduct(0.058,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: -0.000000, rot-vel: 2.551611}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 136.268967, DeltaTheta: 0.442232}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.136
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.637/PFar + 0.363/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.308/PNear + 0.692/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.308] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.308,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.308,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.692] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.692,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.692,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.33365e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.308,Zero),AlgebraicProduct(0.692,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0405611
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.507/VSlowLeft + 0.844/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.308,VSlowLeft),AlgebraicProduct(0.692,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 0.000000, rot-vel: 2.323980}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 134.640747, DeltaTheta: 0.217991}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.135
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.654/PFar + 0.346/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.837/PNear + 0.163/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.837] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.837,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.163] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.163,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.55098e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.837,Zero),AlgebraicProduct(0.163,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0304758
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.381/VSlowLeft + 0.385/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.837,VSlowLeft),AlgebraicProduct(0.163,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: -0.000000, rot-vel: 1.746137}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 134.652664, DeltaTheta: 0.241910}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.135
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.653/PFar + 0.347/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.781/PNear + 0.219/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.781] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.781,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.781,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.219] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.219,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.219,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.54811e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.781,Zero),AlgebraicProduct(0.219,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0320398
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.400/VSlowLeft + 0.456/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.781,VSlowLeft),AlgebraicProduct(0.219,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: -0.000000, rot-vel: 1.835743}
[ DORIS] [2018-03-14 16:30:29]: {Distance: 136.066864, DeltaTheta: 0.064982}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.136
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.639/PFar + 0.361/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.639] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.639,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.639,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.361] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.361,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.361,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 47.1194
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.644/Forward + 0.356/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.639,Forward),AlgebraicProduct(0.361,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 6.14247e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.639,Zero),AlgebraicProduct(0.361,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:29]: {lin-vel: 47.119403, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 136.279160, DeltaTheta: 0.468892}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.136
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.637/PFar + 0.363/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.245/PNear + 0.755/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.245] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.245,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.245,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.755] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.755,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.755,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.3094e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.245,Zero),AlgebraicProduct(0.755,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0412552
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.516/VSlowLeft + 0.875/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.245,VSlowLeft),AlgebraicProduct(0.755,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 2.363749}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 136.279160, DeltaTheta: 0.381230}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.136
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.637/PFar + 0.363/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.007
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.452/PNear + 0.548/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.452] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.452,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.548] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.548,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.08838e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,Zero),AlgebraicProduct(0.548,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0386559
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.483/VSlowLeft + 0.757/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.452,VSlowLeft),AlgebraicProduct(0.548,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 2.214821}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 132.150284, DeltaTheta: 0.464365}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.678/PFar + 0.322/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.256/PNear + 0.744/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.256] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.256,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.256,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.744] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.744,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.744,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.6634e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.256,Zero),AlgebraicProduct(0.744,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0411427
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.514/VSlowLeft + 0.870/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.256,VSlowLeft),AlgebraicProduct(0.744,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 2.357300}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 131.370438, DeltaTheta: 0.175876}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.131
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.686/PFar + 0.314/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.937/PNear + 0.063/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.937] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.937,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.937,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.063] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.063,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.063,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.90036e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.937,Zero),AlgebraicProduct(0.063,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0273209
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.342/VSlowLeft + 0.242/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.937,VSlowLeft),AlgebraicProduct(0.063,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 1.565374}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 131.377853, DeltaTheta: -0.361063}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.131
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.686/PFar + 0.314/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.006
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.500/NFar + 0.500/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.500] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.500,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.500,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.500] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.500,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.500,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.81326e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.500,Zero),AlgebraicProduct(0.500,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0268039
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.739/SlowRight + 0.782/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.500,SlowRight),AlgebraicProduct(0.500,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: -1.535751}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 132.100845, DeltaTheta: -0.820295}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.679/PFar + 0.321/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.014
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.432/NVeryFar + 0.568/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.432] rule: if angleError is NVeryFar then linearVelocity is Zero and angularVelocity is FastRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.432,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.432,FastRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.568] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.568,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.568,SlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.10327e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.432,Zero),AlgebraicProduct(0.568,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0385016
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.917/SlowRight + 0.250/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.432,FastRight),AlgebraicProduct(0.568,SlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: -2.205977}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 132.405991, DeltaTheta: -0.302120}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.676/PFar + 0.324/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.005
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.361/NFar + 0.639/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.361] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.361,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.361,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.639] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.639,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.639,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.24093e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.361,Zero),AlgebraicProduct(0.639,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0257026
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.723/SlowRight + 0.832/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.361,SlowRight),AlgebraicProduct(0.639,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: -1.472651}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 132.405991, DeltaTheta: 0.048530}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.676/PFar + 0.324/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.676] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.676,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.324] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.324,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 46.3644
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.682/Forward + 0.318/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.676,Forward),AlgebraicProduct(0.324,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.70307e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.676,Zero),AlgebraicProduct(0.324,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: 46.364386, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 132.144547, DeltaTheta: 0.809689}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.679/PFar + 0.321/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.014
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.587/PFar + 0.413/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.587] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.587,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.413] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.413,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.76633e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.587,Zero),AlgebraicProduct(0.413,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0523908
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.619/SlowLeft + 0.381/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.587,SlowLeft),AlgebraicProduct(0.413,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 3.001774}
[ DORIS] [2018-03-14 16:30:30]: {Distance: 131.981812, DeltaTheta: 1.181734}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.132
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.680/PFar + 0.320/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.021
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:30]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 128.820221, DeltaTheta: 1.210741}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.129
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.712/PFar + 0.288/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.021
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 127.376389, DeltaTheta: 1.086874}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.127
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.726/PFar + 0.274/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.019
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.103/PFar + 0.897/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.103] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.103,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.103,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.897] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.897,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.897,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -2.98774e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.103,Zero),AlgebraicProduct(0.897,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0629856
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.137/SlowLeft + 0.863/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.103,SlowLeft),AlgebraicProduct(0.897,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: 3.608806}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 125.353004, DeltaTheta: 0.693355}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.125
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.746/PFar + 0.254/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.790/PFar + 0.210/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.790] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.790,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.790,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.210] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.210,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.210,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.99782e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.790,Zero),AlgebraicProduct(0.210,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0478204
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.826/SlowLeft + 0.174/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.790,SlowLeft),AlgebraicProduct(0.210,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: 2.739909}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 125.353004, DeltaTheta: 0.167380}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.125
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.746/PFar + 0.254/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.957/PNear + 0.043/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.957] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.957,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.957,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.043] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.043,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.043,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.77697e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.957,Zero),AlgebraicProduct(0.043,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0266157
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.333/VSlowLeft + 0.210/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.957,VSlowLeft),AlgebraicProduct(0.043,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: 1.524965}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 123.875511, DeltaTheta: -0.237119}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.124
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.761/PFar + 0.239/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.004
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.208/NFar + 0.792/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.208] rule: if angleError is NFar then linearVelocity is Zero and angularVelocity is SlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.208,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.208,SlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.792] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.792,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.792,VSlowRight)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.63795e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.208,Zero),AlgebraicProduct(0.792,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0241786
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.700/SlowRight + 0.901/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.208,SlowRight),AlgebraicProduct(0.792,VSlowRight)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: -1.385332}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 125.503731, DeltaTheta: 0.023737}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.126
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.745/PFar + 0.255/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.745] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.255] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.9548
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.752/Forward + 0.248/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.745,Forward),AlgebraicProduct(0.255,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.79844e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.745,Zero),AlgebraicProduct(0.255,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: 44.954806, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 125.503731, DeltaTheta: -0.063925}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.126
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.745/PFar + 0.255/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.745] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.745,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.255] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.255,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.9548
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.752/Forward + 0.248/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.745,Forward),AlgebraicProduct(0.255,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 5.79844e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.745,Zero),AlgebraicProduct(0.255,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: 44.954806, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 124.002419, DeltaTheta: -0.074855}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.124
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.760/PFar + 0.240/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.005/NNear + 0.995/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.005] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.005,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.756] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.756,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.239] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.239,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.239,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 44.4228
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.779/Forward + 0.221/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,Zero),AlgebraicProduct(0.756,Forward),AlgebraicProduct(0.239,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.00010857
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.335/SlowRight + 0.005/VSlowRight + 0.995/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.005,VSlowRight),AlgebraicProduct(0.756,Zero),AlgebraicProduct(0.239,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: 44.422846, rot-vel: -0.006221}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 121.302803, DeltaTheta: 0.156514}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.121
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.787/PFar + 0.213/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.003
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.982/PNear + 0.018/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.982] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.982,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.982,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.018] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.018,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.018,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.36007e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.982,Zero),AlgebraicProduct(0.018,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.025677
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.321/VSlowLeft + 0.167/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.982,VSlowLeft),AlgebraicProduct(0.018,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: -0.000000, rot-vel: 1.471182}
[ DORIS] [2018-03-14 16:30:31]: {Distance: 118.140533, DeltaTheta: 0.071868}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.118
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.819/PFar + 0.181/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.001
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.819] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.819,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.819,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.181] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.181,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.181,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 43.4775
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.826/Forward + 0.174/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.819,Forward),AlgebraicProduct(0.181,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 4.86314e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.819,Zero),AlgebraicProduct(0.181,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:31]: {lin-vel: 43.477472, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 112.616776, DeltaTheta: 0.537703}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.113
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.874/PFar + 0.126/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.083/PNear + 0.917/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.083] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.083,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.083,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.917] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.917,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.917,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.18109e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.083,Zero),AlgebraicProduct(0.917,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0427287
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.534/VSlowLeft + 0.942/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.083,VSlowLeft),AlgebraicProduct(0.917,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 2.448174}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 110.485367, DeltaTheta: 0.947769}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.110
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.895/PFar + 0.105/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.017
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.346/PFar + 0.654/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.346] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.346,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.346,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.654] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.654,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.654,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.57157e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.346,Zero),AlgebraicProduct(0.654,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.057829
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.371/SlowLeft + 0.629/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.346,SlowLeft),AlgebraicProduct(0.654,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.313360}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 108.485626, DeltaTheta: 0.876771}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.108
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.915/PFar + 0.085/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.015
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.470/PFar + 0.530/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.470] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.470,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.530] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.530,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -6.18231e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,Zero),AlgebraicProduct(0.530,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0550509
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.498/SlowLeft + 0.502/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.470,SlowLeft),AlgebraicProduct(0.530,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.154184}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 108.181404, DeltaTheta: 0.805123}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.108
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.918/PFar + 0.082/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.014
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.595/PFar + 0.405/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.595] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.595,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.595,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.405] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.405,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.405,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.79317e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.595,Zero),AlgebraicProduct(0.405,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0522096
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.627/SlowLeft + 0.373/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.595,SlowLeft),AlgebraicProduct(0.405,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 2.991389}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 107.263481, DeltaTheta: 1.474634}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.107
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.927/PFar + 0.073/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.026
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 108.263176, DeltaTheta: 1.373757}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.108
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.917/PFar + 0.083/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.024
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 107.318001, DeltaTheta: 1.320001}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.107
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.927/PFar + 0.073/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.023
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 105.605309, DeltaTheta: 0.896975}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.106
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.944/PFar + 0.056/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.016
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.434/PFar + 0.566/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.434] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.434,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.566] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.566,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.14792e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.434,Zero),AlgebraicProduct(0.566,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0558474
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.461/SlowLeft + 0.539/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.434,SlowLeft),AlgebraicProduct(0.566,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 3.199821}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 105.605309, DeltaTheta: 0.458662}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.106
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.944/PFar + 0.056/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.270/PNear + 0.730/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.270] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.270,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.270,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.730] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.730,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.730,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.65288e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.270,Zero),AlgebraicProduct(0.730,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0409978
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.512/VSlowLeft + 0.864/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.270,VSlowLeft),AlgebraicProduct(0.730,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: -0.000000, rot-vel: 2.349003}
[ DORIS] [2018-03-14 16:30:32]: {Distance: 104.664680, DeltaTheta: -0.006936}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.105
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.953/PFar + 0.047/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.953] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.953,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.047] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.047,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 40.8685
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.957/Forward + 0.043/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,Forward),AlgebraicProduct(0.047,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 4.03485e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.953,Zero),AlgebraicProduct(0.047,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:32]: {lin-vel: 40.868471, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 105.973473, DeltaTheta: -0.038805}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.106
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.940/PFar + 0.060/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.000
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 1.000/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.940] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.940,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.940,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.060] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.060,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.060,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 41.1156
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.000/Backwards + 0.000/MediumBackwards + 0.000/Zero + 0.000/MediumForward + 0.944/Forward + 0.056/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.940,Forward),AlgebraicProduct(0.060,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 4.24242e-18
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.333/SlowRight + 0.000/VSlowRight + 1.000/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.940,Zero),AlgebraicProduct(0.060,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: 41.115592, rot-vel: 0.000000}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 104.973473, DeltaTheta: -0.127255}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.105
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.950/PFar + 0.050/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = -0.002
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.708/NNear + 0.292/Zero + 0.000/PNear + 0.000/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.708] rule: if angleError is NNear then linearVelocity is Zero and angularVelocity is VSlowRight
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.708,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.708,VSlowRight)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.277] rule: if angleError is Zero and distanceError is PFar then linearVelocity is Forward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.277,Forward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.277,Zero)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.014] rule: if angleError is Zero and distanceError is PVeryFar then linearVelocity is FastForward and angularVelocity is Zero
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.014,FastForward)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.014,Zero)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 11.928
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.135/Backwards + 0.000/MediumBackwards + 0.404/Zero + 0.596/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.708,Zero),AlgebraicProduct(0.277,Forward),AlgebraicProduct(0.014,FastForward)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = -0.0156476
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.570/SlowRight + 0.711/VSlowRight + 0.289/Zero + 0.000/VSlowLeft + 0.000/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.708,VSlowRight),AlgebraicProduct(0.277,Zero),AlgebraicProduct(0.014,Zero)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: 11.927952, rot-vel: -0.896540}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 102.356361, DeltaTheta: 0.707293}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.102
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.976/PFar + 0.024/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.766/PFar + 0.234/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.766] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.766,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.234] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.234,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.27102e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,Zero),AlgebraicProduct(0.234,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0483597
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.802/SlowLeft + 0.198/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.766,SlowLeft),AlgebraicProduct(0.234,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 2.770809}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 99.364853, DeltaTheta: 1.702086}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.099
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.007/PNear + 0.993/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.030
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 97.129799, DeltaTheta: 1.741265}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.097
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.032/PNear + 0.968/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.030
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 96.584534, DeltaTheta: 1.843467}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.097
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.038/PNear + 0.962/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.032
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 95.216537, DeltaTheta: 1.508195}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.095
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.053/PNear + 0.947/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.026
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 96.216270, DeltaTheta: 1.143693}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.096
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.042/PNear + 0.958/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.020
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.004/PFar + 0.996/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.004] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.004,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.996] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.996,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.37796e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,Zero),AlgebraicProduct(0.996,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0649264
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.049/SlowLeft + 0.951/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.004,SlowLeft),AlgebraicProduct(0.996,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.720012}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 97.882698, DeltaTheta: 0.670966}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.098
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.024/PNear + 0.976/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.012
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.829/PFar + 0.171/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.829] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.829,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.829,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.171] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.171,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.171,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.59292e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.829,Zero),AlgebraicProduct(0.171,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0469612
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.865/SlowLeft + 0.135/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.829,SlowLeft),AlgebraicProduct(0.171,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 2.690680}
[ DORIS] [2018-03-14 16:30:33]: {Distance: 96.252136, DeltaTheta: 1.009131}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.096
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.042/PNear + 0.958/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.018
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.239/PFar + 0.761/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.239] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.239,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.239,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.761] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.761,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.761,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -7.89492e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.239,Zero),AlgebraicProduct(0.761,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0601632
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.265/SlowLeft + 0.735/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.239,SlowLeft),AlgebraicProduct(0.761,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:33]: {lin-vel: -0.000000, rot-vel: 3.447100}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 95.252228, DeltaTheta: 0.490989}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.095
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.053/PNear + 0.947/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.193/PNear + 0.807/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.193] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.193,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.807] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.807,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -5.4455e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,Zero),AlgebraicProduct(0.807,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0417752
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.522/VSlowLeft + 0.899/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.193,VSlowLeft),AlgebraicProduct(0.807,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 2.393544}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 94.305397, DeltaTheta: 0.511101}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.063/PNear + 0.937/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.146/PNear + 0.854/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.146] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.146,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.854] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.854,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 7.96245e-17
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.146,Zero),AlgebraicProduct(0.854,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0422087
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.528/VSlowLeft + 0.919/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.146,VSlowLeft),AlgebraicProduct(0.854,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: 0.000000, rot-vel: 2.418381}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 94.069252, DeltaTheta: 1.491408}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.066/PNear + 0.934/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.026
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 94.069252, DeltaTheta: 1.316083}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.066/PNear + 0.934/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.023
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 93.732323, DeltaTheta: 1.849997}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.094
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.070/PNear + 0.930/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.032
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 93.292473, DeltaTheta: 2.257604}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.093
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.075/PNear + 0.925/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.039
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 93.292473, DeltaTheta: 1.819291}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.093
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.075/PNear + 0.925/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.032
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 91.799278, DeltaTheta: 1.478944}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.092
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.091/PNear + 0.909/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.026
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 91.799278, DeltaTheta: 1.128294}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.092
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.091/PNear + 0.909/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.020
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.031/PFar + 0.969/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.031] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.031,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.031,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.969] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.969,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.969,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -4.546e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.031,Zero),AlgebraicProduct(0.969,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0644117
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.072/SlowLeft + 0.928/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.031,SlowLeft),AlgebraicProduct(0.969,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 3.690521}
[ DORIS] [2018-03-14 16:30:34]: {Distance: 90.529289, DeltaTheta: 0.786518}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.091
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.105/PNear + 0.895/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.014
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.627/PFar + 0.373/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.627] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.627,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.627,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.373] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.373,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.373,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.44299e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.627,Zero),AlgebraicProduct(0.373,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0514718
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.660/SlowLeft + 0.340/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.627,SlowLeft),AlgebraicProduct(0.373,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:34]: {lin-vel: -0.000000, rot-vel: 2.949116}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 90.529289, DeltaTheta: 0.435868}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.091
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.105/PNear + 0.895/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.008
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.323/PNear + 0.677/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.323] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.323,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.323,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.677] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.677,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.677,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -3.20999e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.323,Zero),AlgebraicProduct(0.677,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0403838
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.505/VSlowLeft + 0.836/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.323,VSlowLeft),AlgebraicProduct(0.677,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 2.313824}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 89.681335, DeltaTheta: 0.553397}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.090
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.115/PNear + 0.885/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.046/PNear + 0.954/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.046] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.046,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.046,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.954] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.954,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.954,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = 2.45886e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.046,Zero),AlgebraicProduct(0.954,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0430091
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.538/VSlowLeft + 0.955/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.046,VSlowLeft),AlgebraicProduct(0.954,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: 0.000000, rot-vel: 2.464242}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.540749, DeltaTheta: 0.534603}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.089
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.127/PNear + 0.873/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.090/PNear + 0.910/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.090] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.090,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.910] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.910,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.910,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.09318e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.090,Zero),AlgebraicProduct(0.910,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0426711
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.533/VSlowLeft + 0.940/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.090,VSlowLeft),AlgebraicProduct(0.910,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 2.444872}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.435448, DeltaTheta: 0.601324}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.088
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.128/PNear + 0.872/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.010
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.950/PFar + 0.050/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.950] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.950,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.050] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.050,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -9.81959e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.950,Zero),AlgebraicProduct(0.050,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0443578
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.984/SlowLeft + 0.016/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.950,SlowLeft),AlgebraicProduct(0.050,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 2.541512}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.435448, DeltaTheta: 0.513662}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.088
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.128/PNear + 0.872/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.009
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.140/PNear + 0.860/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.140] rule: if angleError is PNear then linearVelocity is Zero and angularVelocity is VSlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.140,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.140,VSlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.860] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.860,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.860,SlowLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.00591e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.140,Zero),AlgebraicProduct(0.860,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0422613
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.528/VSlowLeft + 0.921/SlowLeft + 0.000/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.140,VSlowLeft),AlgebraicProduct(0.860,SlowLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 2.421397}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.277901, DeltaTheta: 1.481060}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.088
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.130/PNear + 0.870/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.026
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.144600, DeltaTheta: 2.208428}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.088
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.132/PNear + 0.868/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.039
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 88.144600, DeltaTheta: 2.033103}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.088
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.132/PNear + 0.868/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.035
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 87.444511, DeltaTheta: 2.274135}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.087
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.140/PNear + 0.860/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.040
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:35]: {Distance: 86.755394, DeltaTheta: 2.394080}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.087
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.147/PNear + 0.853/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.042
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:35]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 86.755394, DeltaTheta: 2.043429}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.087
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.147/PNear + 0.853/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.036
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 86.122185, DeltaTheta: 2.305861}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.154/PNear + 0.846/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.040
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 86.182167, DeltaTheta: 2.171778}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.154/PNear + 0.846/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.038
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 86.182167, DeltaTheta: 1.821128}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.154/PNear + 0.846/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.032
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.783691, DeltaTheta: 1.372651}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.158/PNear + 0.842/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.024
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.783691, DeltaTheta: 1.022001}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.158/PNear + 0.842/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.018
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.216/PFar + 0.784/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 0.216] rule: if angleError is PFar then linearVelocity is Zero and angularVelocity is SlowLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.216,SlowLeft)
/src/rule/Rule.cpp::trigger[118]:[firing with 0.784] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(0.784,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -1.02535e-15
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.216,Zero),AlgebraicProduct(0.784,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.0606421
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.244/SlowLeft + 0.756/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(0.216,SlowLeft),AlgebraicProduct(0.784,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.474534}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.307098, DeltaTheta: 1.430400}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.085
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.163/PNear + 0.837/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.025
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.520065, DeltaTheta: 1.357236}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.161/PNear + 0.839/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.024
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.577026, DeltaTheta: 2.698641}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.160/PNear + 0.840/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.047
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:36]: {Distance: 85.577026, DeltaTheta: 2.347991}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.086
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.160/PNear + 0.840/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.041
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:36]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 85.306046, DeltaTheta: 2.986574}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.085
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.163/PNear + 0.837/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.052
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 85.306046, DeltaTheta: 2.548261}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.085
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.163/PNear + 0.837/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.044
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 84.476028, DeltaTheta: 2.712689}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.172/PNear + 0.828/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.047
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 84.049843, DeltaTheta: 3.425088}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.177/PNear + 0.823/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.060
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 84.049843, DeltaTheta: 2.986775}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.177/PNear + 0.823/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.052
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 83.565918, DeltaTheta: 2.565854}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.183/PNear + 0.817/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.045
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 83.499458, DeltaTheta: 3.508821}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.183/PNear + 0.817/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.061
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 83.499458, DeltaTheta: 3.158171}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.183/PNear + 0.817/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.055
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 83.240791, DeltaTheta: 3.959693}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.186/PNear + 0.814/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.069
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:37]: {Distance: 83.240791, DeltaTheta: 3.609042}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.186/PNear + 0.814/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.063
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:37]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 83.520844, DeltaTheta: 4.848984}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.084
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.183/PNear + 0.817/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.085
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 83.144592, DeltaTheta: 5.687702}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.187/PNear + 0.813/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.099
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 83.144592, DeltaTheta: 5.337051}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.083
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.187/PNear + 0.813/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.093
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 82.463852, DeltaTheta: 6.045745}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.195/PNear + 0.805/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.106
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 82.339813, DeltaTheta: 6.908980}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.196/PNear + 0.804/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.121
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 82.339813, DeltaTheta: 6.470668}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.196/PNear + 0.804/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.113
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 81.619820, DeltaTheta: 6.218807}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.204/PNear + 0.796/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.109
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 81.619820, DeltaTheta: 5.868157}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.204/PNear + 0.796/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.102
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 81.577316, DeltaTheta: 5.701314}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.082
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.205/PNear + 0.795/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.100
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:38]: {Distance: 80.912674, DeltaTheta: 6.534742}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.081
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.212/PNear + 0.788/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.114
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:38]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 80.463486, DeltaTheta: 7.331250}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.080
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.217/PNear + 0.783/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.128
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 80.463486, DeltaTheta: 6.892937}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.080
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.217/PNear + 0.783/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.120
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 79.674957, DeltaTheta: 7.647066}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.080
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.226/PNear + 0.774/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.133
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 78.809868, DeltaTheta: 7.374750}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.079
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.235/PNear + 0.765/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.129
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 78.809868, DeltaTheta: 7.024100}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.079
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.235/PNear + 0.765/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.123
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 76.399200, DeltaTheta: 9.935666}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.076
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.262/PNear + 0.738/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.173
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 73.546295, DeltaTheta: 12.546819}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.074
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.294/PNear + 0.706/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.219
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 72.173531, DeltaTheta: 13.364062}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.072
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.309/PNear + 0.691/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.233
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 70.207527, DeltaTheta: 15.360554}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.070
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.331/PNear + 0.669/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.268
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:39]: {Distance: 68.995155, DeltaTheta: 16.405790}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.069
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.344/PNear + 0.656/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.286
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:39]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 67.969292, DeltaTheta: 16.816366}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.356/PNear + 0.644/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.294
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 68.572426, DeltaTheta: 18.639437}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.069
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.349/PNear + 0.651/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.325
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 69.437401, DeltaTheta: 20.526289}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.069
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.340/PNear + 0.660/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.358
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 68.769966, DeltaTheta: 20.988619}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.069
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.347/PNear + 0.653/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.366
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 68.089340, DeltaTheta: 22.618582}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.355/PNear + 0.645/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.395
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 68.090828, DeltaTheta: 20.173346}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.355/PNear + 0.645/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.352
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 67.615112, DeltaTheta: 19.663052}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.360/PNear + 0.640/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.343
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 66.888725, DeltaTheta: 22.729721}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.067
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.368/PNear + 0.632/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.397
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}
[ DORIS] [2018-03-14 16:30:40]: {Distance: 68.271950, DeltaTheta: 24.534845}
/src/Engine.cpp::process[284]:===============
/src/Engine.cpp::process[285]:CURRENT INPUTS:
/src/Engine.cpp::process[290]:distanceError.input = 0.068
/src/Engine.cpp::process[291]:distanceError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.353/PNear + 0.647/PFar + 0.000/PVeryFar
/src/Engine.cpp::process[290]:angleError.input = 0.428
/src/Engine.cpp::process[291]:angleError.fuzzy = 0.000/NVeryFar + 0.000/NFar + 0.000/NNear + 0.000/Zero + 0.000/PNear + 0.000/PFar + 1.000/PVeryFar
/src/Engine.cpp::process[302]:===============
/src/Engine.cpp::process[303]:RULE BLOCK: mamdani
/src/activation/General.cpp::activate[53]:Activation: General 
/src/rule/Rule.cpp::trigger[118]:[firing with 1.000] rule: if angleError is PVeryFar then linearVelocity is Zero and angularVelocity is FastLeft
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,Zero)
/src/term/Aggregated.cpp::addTerm[205]:Aggregating AlgebraicProduct(1.000,FastLeft)
/src/Engine.cpp::process[313]:===============
/src/Engine.cpp::process[314]:CURRENT OUTPUTS:
/src/Engine.cpp::process[319]:linearVelocity.default = 0
/src/Engine.cpp::process[322]:linearVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:linearVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:linearVelocity.output = -8.51385e-16
/src/Engine.cpp::process[330]:linearVelocity.fuzzy = 0.000/FastBackwards + 0.333/Backwards + 0.000/MediumBackwards + 1.000/Zero + 0.000/MediumForward + 0.000/Forward + 0.000/FastForward
/src/Engine.cpp::process[331]:linearVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,Zero)]
/src/Engine.cpp::process[319]:angularVelocity.default = 0
/src/Engine.cpp::process[322]:angularVelocity.lockValueInRange = 0
/src/Engine.cpp::process[325]:angularVelocity.lockPreviousValue= 0
/src/Engine.cpp::process[328]:angularVelocity.output = 0.065
/src/Engine.cpp::process[330]:angularVelocity.fuzzy = 0.000/FastRight + 0.000/SlowRight + 0.000/VSlowRight + 0.000/Zero + 0.000/VSlowLeft + 0.045/SlowLeft + 0.955/FastLeft
/src/Engine.cpp::process[331]:angularVelocity: Aggregated AlgebraicSum[AlgebraicProduct(1.000,FastLeft)]
/src/Engine.cpp::process[336]:==============
[ DORIS] [2018-03-14 16:30:40]: {lin-vel: -0.000000, rot-vel: 3.724226}